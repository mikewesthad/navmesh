!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("phaser")):"function"==typeof define&&define.amd?define(["phaser"],n):"object"==typeof exports?exports.PhaserNavMeshPlugin=n(require("phaser")):t.PhaserNavMeshPlugin=n(t.Phaser)}(window,function(t){return function(t){var n={};function e(s){if(n[s])return n[s].exports;var i=n[s]={i:s,l:!1,exports:{}};return t[s].call(i.exports,i,i.exports,e),i.l=!0,i.exports}return e.m=t,e.c=n,e.d=function(t,n,s){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:s})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(e.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var i in t)e.d(s,i,function(n){return t[n]}.bind(null,i));return s},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=2)}([function(t,n,e){var s,i,o;!function(n){"object"==typeof t.exports?t.exports=n():(i=[],void 0===(o="function"==typeof(s=n)?s.apply(void 0,i):s)||(t.exports=o))}(function(){function t(t){for(var n=t,e=[];n.parent;)e.unshift(n),n=n.parent;return e}var n={search:function(e,s,o,r){e.cleanDirty();var h=(r=r||{}).heuristic||n.heuristics.manhattan,a=r.closest||!1,c=new i(function(t){return t.f}),u=s;for(s.h=h(s,o),e.markDirty(s),c.push(s);c.size()>0;){var l=c.pop();if(l===o)return t(l);l.closed=!0;for(var p=e.neighbors(l),d=0,g=p.length;d<g;++d){var y=p[d];if(!y.closed&&!y.isWall()){var f=l.g+y.getCost(l),b=y.visited;(!b||f<y.g)&&(y.visited=!0,y.parent=l,y.h=y.h||h(y,o),y.g=f,y.f=y.g+y.h,e.markDirty(y),a&&(y.h<u.h||y.h===u.h&&y.g<u.g)&&(u=y),b?c.rescoreElement(y):c.push(y))}}}return a?t(u):[]},heuristics:{manhattan:function(t,n){return Math.abs(n.x-t.x)+Math.abs(n.y-t.y)},diagonal:function(t,n){var e=Math.sqrt(2),s=Math.abs(n.x-t.x),i=Math.abs(n.y-t.y);return 1*(s+i)+(e-2)*Math.min(s,i)}},cleanNode:function(t){t.f=0,t.g=0,t.h=0,t.visited=!1,t.closed=!1,t.parent=null}};function e(t,n){n=n||{},this.nodes=[],this.diagonal=!!n.diagonal,this.grid=[];for(var e=0;e<t.length;e++){this.grid[e]=[];for(var i=0,o=t[e];i<o.length;i++){var r=new s(e,i,o[i]);this.grid[e][i]=r,this.nodes.push(r)}}this.init()}function s(t,n,e){this.x=t,this.y=n,this.weight=e}function i(t){this.content=[],this.scoreFunction=t}return e.prototype.init=function(){this.dirtyNodes=[];for(var t=0;t<this.nodes.length;t++)n.cleanNode(this.nodes[t])},e.prototype.cleanDirty=function(){for(var t=0;t<this.dirtyNodes.length;t++)n.cleanNode(this.dirtyNodes[t]);this.dirtyNodes=[]},e.prototype.markDirty=function(t){this.dirtyNodes.push(t)},e.prototype.neighbors=function(t){var n=[],e=t.x,s=t.y,i=this.grid;return i[e-1]&&i[e-1][s]&&n.push(i[e-1][s]),i[e+1]&&i[e+1][s]&&n.push(i[e+1][s]),i[e]&&i[e][s-1]&&n.push(i[e][s-1]),i[e]&&i[e][s+1]&&n.push(i[e][s+1]),this.diagonal&&(i[e-1]&&i[e-1][s-1]&&n.push(i[e-1][s-1]),i[e+1]&&i[e+1][s-1]&&n.push(i[e+1][s-1]),i[e-1]&&i[e-1][s+1]&&n.push(i[e-1][s+1]),i[e+1]&&i[e+1][s+1]&&n.push(i[e+1][s+1])),n},e.prototype.toString=function(){for(var t=[],n=this.grid,e=0;e<n.length;e++){for(var s=[],i=n[e],o=0;o<i.length;o++)s.push(i[o].weight);t.push(s.join(" "))}return t.join("\n")},s.prototype.toString=function(){return"["+this.x+" "+this.y+"]"},s.prototype.getCost=function(t){return t&&t.x!=this.x&&t.y!=this.y?1.41421*this.weight:this.weight},s.prototype.isWall=function(){return 0===this.weight},i.prototype={push:function(t){this.content.push(t),this.sinkDown(this.content.length-1)},pop:function(){var t=this.content[0],n=this.content.pop();return this.content.length>0&&(this.content[0]=n,this.bubbleUp(0)),t},remove:function(t){var n=this.content.indexOf(t),e=this.content.pop();n!==this.content.length-1&&(this.content[n]=e,this.scoreFunction(e)<this.scoreFunction(t)?this.sinkDown(n):this.bubbleUp(n))},size:function(){return this.content.length},rescoreElement:function(t){this.sinkDown(this.content.indexOf(t))},sinkDown:function(t){for(var n=this.content[t];t>0;){var e=(t+1>>1)-1,s=this.content[e];if(!(this.scoreFunction(n)<this.scoreFunction(s)))break;this.content[e]=n,this.content[t]=s,t=e}},bubbleUp:function(t){for(var n=this.content.length,e=this.content[t],s=this.scoreFunction(e);;){var i,o=t+1<<1,r=o-1,h=null;if(r<n){var a=this.content[r];(i=this.scoreFunction(a))<s&&(h=r)}if(o<n){var c=this.content[o];this.scoreFunction(c)<(null===h?s:i)&&(h=o)}if(null===h)break;this.content[t]=this.content[h],this.content[h]=e,t=h}}},{astar:n,Graph:e}})},function(n,e){n.exports=t},function(t,n,e){"use strict";e.r(n);var s=e(1),i=e.n(s),o=e(0),r=e.n(o);class h{constructor(t,n){this.x=t||0,this.y=n||0}equals(t){return this.x===t.x&&this.y===t.y}angle(t){return Math.atan2(t.y-this.y,t.x-this.x)}distance(t){const n=t.x-this.x,e=t.y-this.y;return Math.sqrt(n*n+e*e)}add(t){this.x+=t.x,this.y+=t.y}subtract(t){this.x-=t.x,this.y-=t.y}clone(){return new h(this.x,this.y)}}class a{constructor(t,n){this.id=t,this.polygon=n,this.edges=n.edges,this.neighbors=[],this.portals=[],this.centroid=this.calculateCentroid(),this.boundingRadius=this.calculateRadius(),this.weight=1}getPoints(){return this.polygon.points}contains(t){return this.polygon.contains(t.x,t.y)||this.isPointOnEdge(t)}calculateCentroid(){const t=new h(0,0),n=this.polygon.points.length;return this.polygon.points.forEach(n=>t.add(n)),t.x/=n,t.y/=n,t}calculateRadius(){let t=0;for(const n of this.polygon.points){const e=this.centroid.distance(n);e>t&&(t=e)}return t}isPointOnEdge({x:t,y:n}){for(const e of this.edges)if(e.pointOnSegment(t,n))return!0;return!1}destroy(){this.neighbors=[],this.portals=[]}toString(){return`NavPoly(id: ${this.id} at: ${this.centroid})`}isWall(){return 0===this.weight}centroidDistance(t){return this.centroid.distance(t.centroid)}getCost(t){return this.centroidDistance(t)}}class c{constructor(t){this.nodes=t,this.init()}neighbors(t){return t.neighbors}navHeuristic(t,n){return t.centroidDistance(n)}destroy(){this.cleanDirty(),this.nodes=[]}}c.prototype.init=r.a.Graph.prototype.init,c.prototype.cleanDirty=r.a.Graph.prototype.cleanDirty,c.prototype.markDirty=r.a.Graph.prototype.markDirty;var u=c;function l(t,n,e){const s=n.x-t.x,i=n.y-t.y;return(e.x-t.x)*i-s*(e.y-t.y)}function p(t,n,e=1e-4){return Math.abs(t-n)<=e}function d(t,n){let e=t-n;const s=e+Math.PI,i=2*Math.PI;return e=s-Math.floor(s/i)*i,e-=Math.PI}function g(t,n,e=1e-4){const s=l(t.start,t.end,n.start),i=l(t.start,t.end,n.end);return!(!p(s,0,e)||!p(i,0,e))}var y=class{constructor(){this.portals=[]}push(t,n=null){null===n&&(n=t),this.portals.push({left:t,right:n})}stringPull(){var t,n,e,s=this.portals,i=[],o=0,r=0,h=0;t=s[0].left,n=s[0].left,e=s[0].right,i.push(t);for(var a=1;a<s.length;a++){var c=s[a].left,u=s[a].right;if(l(t,e,u)<=0){if(!(t.equals(e)||l(t,n,u)>0)){i.push(n),n=t=n,e=t,r=o=r,h=o,a=o;continue}e=u,h=a}if(l(t,n,c)>=0){if(!(t.equals(n)||l(t,e,c)<0)){i.push(e),n=t=e,e=t,r=o=h,h=o,a=o;continue}n=c,r=a}}return 0!==i.length&&i[i.length-1].equals(s[s.length-1].left)||i.push(s[s.length-1].left),this.path=i,i}};class f{constructor(t,n,e,s){this.start=new h(t,n),this.end=new h(e,s),this.left=Math.min(t,e),this.right=Math.max(t,e),this.top=Math.min(n,s),this.bottom=Math.max(n,s)}pointOnSegment(t,n){return t>=this.left&&t<=this.right&&n>=this.top&&n<=this.bottom&&this.pointOnLine(t,n)}pointOnLine(t,n){return(t-this.left)*(this.bottom-this.top)==(this.right-this.left)*(n-this.top)}}class b{constructor(t,n=!0){this.points=t,this.edges=[];for(let n=1;n<t.length;n++){const e=t[n-1],s=t[n];this.edges.push(new f(e.x,e.y,s.x,s.y))}if(n){const n=t[0],e=t[t.length-1];this.edges.push(new f(n.x,n.y,e.x,e.y))}}contains(t,n){let e=!1;for(let s=-1,i=this.points.length-1;++s<this.points.length;i=s){const o=this.points[s].x,r=this.points[s].y,h=this.points[i].x,a=this.points[i].y;(r<=n&&n<a||a<=n&&n<r)&&t<(h-o)*(n-r)/(a-r)+o&&(e=!e)}return e}}var v=class{constructor(t,n=0){this._meshShrinkAmount=n;const e=t.map(t=>{const n=t.map(t=>new h(t.x,t.y));return new b(n)});this._navPolygons=e.map((t,n)=>new a(n,t)),this._calculateNeighbors(),this._graph=new u(this._navPolygons)}getPolygons(){return this._navPolygons}destroy(){this._graph.destroy();for(const t of this._navPolygons)t.destroy();this._navPolygons=[]}findPath(t,n){let e,s,i=null,o=null,a=Number.MAX_VALUE,c=Number.MAX_VALUE;const u=new h(t.x,t.y),l=new h(n.x,n.y);for(const t of this._navPolygons)s=t.boundingRadius,(e=t.centroid.distance(u))<=a&&e<=s&&t.contains(u)&&(i=t,a=e),(e=t.centroid.distance(l))<=c&&e<=s&&t.contains(l)&&(o=t,c=e);if(!i&&this._meshShrinkAmount>0)for(const t of this._navPolygons)if(s=t.boundingRadius+this._meshShrinkAmount,(e=t.centroid.distance(u))<=s){const{distance:n}=this._projectPointToPolygon(u,t);n<=this._meshShrinkAmount&&n<a&&(i=t,a=n)}if(!o&&this._meshShrinkAmount>0)for(const t of this._navPolygons)if(s=t.boundingRadius+this._meshShrinkAmount,(e=t.centroid.distance(l))<=s){const{distance:n}=this._projectPointToPolygon(l,t);n<=this._meshShrinkAmount&&n<c&&(o=t,c=n)}if(!i||!o)return null;if(i===o)return[u,l];const p=r.a.astar.search(this._graph,i,o,{heuristic:this._graph.navHeuristic});if(0===p.length)return null;p.unshift(i);const d=new y;d.push(u);for(let t=0;t<p.length-1;t++){const n=p[t],e=p[t+1];let s=null;for(let t=0;t<n.neighbors.length;t++)n.neighbors[t].id===e.id&&(s=n.portals[t]);d.push(s.start,s.end)}d.push(l),d.stringPull();let g=null;const f=[];for(const t of d.path){const n=t.clone();g&&n.equals(g)||f.push(n),g=n}return f}_calculateNeighbors(){for(let t=0;t<this._navPolygons.length;t++){const n=this._navPolygons[t];for(let e=t+1;e<this._navPolygons.length;e++){const t=this._navPolygons[e];if(!(n.centroid.distance(t.centroid)>n.boundingRadius+t.boundingRadius))for(const e of n.edges)for(const s of t.edges){if(!g(e,s))continue;const i=this._getSegmentOverlap(e,s);if(!i)continue;n.neighbors.push(t),t.neighbors.push(n);const[o,r]=i;let h=n.centroid.angle(e.start),a=n.centroid.angle(i[0]),c=n.centroid.angle(i[1]),u=d(h,a),l=d(h,c);u<l?n.portals.push(new f(o.x,o.y,r.x,r.y)):n.portals.push(new f(r.x,r.y,o.x,o.y)),h=t.centroid.angle(s.start),a=t.centroid.angle(i[0]),c=t.centroid.angle(i[1]),(u=d(h,a))<(l=d(h,c))?t.portals.push(new f(o.x,o.y,r.x,r.y)):t.portals.push(new f(r.x,r.y,o.x,o.y))}}}}_getSegmentOverlap(t,n){const e=[{line:t,point:t.start},{line:t,point:t.end},{line:n,point:n.start},{line:n,point:n.end}];e.sort(function(t,n){return t.point.x<n.point.x?-1:t.point.x>n.point.x?1:t.point.y<n.point.y?-1:t.point.y>n.point.y?1:0});const s=e[0].line===e[1].line,i=e[1].point.equals(e[2].point);return s||i?null:[e[1].point,e[2].point]}_projectPointToPolygon(t,n){let e=null,s=Number.MAX_VALUE;for(const i of n.edges){const n=this._projectPointToEdge(t,i),o=t.distance(n);(null===e||o<s)&&(s=o,e=n)}return{point:e,distance:s}}_distanceSquared(t,n){const e=n.x-t.x,s=n.y-t.y;return e*e+s*s}_projectPointToEdge(t,n){const e=n.start,s=n.end,i=this._distanceSquared(e,s);let o=((t.x-e.x)*(s.x-e.x)+(t.y-e.y)*(s.y-e.y))/i;return o=function(t,n,e){return t<n&&(t=n),t>e&&(t=e),t}(o,0,1),new h(e.x+o*(s.x-e.x),e.y+o*(s.y-e.y))}};class x{constructor(t,n,e,s=0){this.key=n,this.plugin=t,this.scene=t.scene,this.debugGraphics=null,this.navMesh=new v(e,s)}findPath(t,n,e=i.a.Geom.Point){const s=this.navMesh.findPath(t,n);return s?s.map(({x:t,y:n})=>new e(t,n)):s}enableDebug(t){return t||this.debugGraphics?t&&(this.debugGraphics&&this.debugGraphics.destroy(),this.debugGraphics=t):this.debugGraphics=this.scene.add.graphics(),this.debugGraphics.visible=!0,this.debugGraphics}disableDebug(){this.debugGraphics&&(this.debugGraphics.visible=!1)}isDebugEnabled(){return this.debugGraphics&&this.debugGraphics.visible}debugDrawClear(){this.debugGraphics&&this.debugGraphics.clear()}debugDrawMesh({drawCentroid:t=!0,drawBounds:n=!1,drawNeighbors:e=!0,drawPortals:s=!0,palette:i=[41136,6965820,13382463,15427649,15583569]}={}){if(!this.debugGraphics)return;this.navMesh.getPolygons().forEach(o=>{const r=i[o.id%i.length];this.debugGraphics.fillStyle(r),this.debugGraphics.fillPoints(o.getPoints(),!0),t&&(this.debugGraphics.fillStyle(0),this.debugGraphics.fillCircle(o.centroid.x,o.centroid.y,4)),n&&(this.debugGraphics.lineStyle(1,16777215),this.debugGraphics.strokeCircle(o.centroid.x,o.centroid.y,o.boundingRadius)),e&&(this.debugGraphics.lineStyle(2,0),o.neighbors.forEach(t=>{this.debugGraphics.lineBetween(o.centroid.x,o.centroid.y,t.centroid.x,t.centroid.y)})),s&&(this.debugGraphics.lineStyle(10,0),o.portals.forEach(t=>this.debugGraphics.lineBetween(t.start.x,t.start.y,t.end.x,t.end.y)))})}debugDrawPath(t,n=65280,e=10,s=1){if(this.debugGraphics&&t&&t.length){this.debugGraphics.lineStyle(e,n,s),this.debugGraphics.strokePoints(t),this.debugGraphics.fillStyle(n,s);const i=1.2*e;if(this.debugGraphics.fillCircle(t[0].x,t[0].y,i,i),t.length>1){const n=t[t.length-1];this.debugGraphics.fillCircle(n.x,n.y,i,i)}}}destroy(){this.navMesh&&this.navMesh.destroy(),this.debugGraphics&&this.debugGraphics.destroy(),this.plugin.removeMesh(this.key),this.navMesh=void 0,this.debugGraphics=void 0,this.plugin=void 0,this.scene=void 0}}e.d(n,"PhaserNavMesh",function(){return x});n.default=class extends i.a.Plugins.ScenePlugin{constructor(t,n){super(t,n),this.phaserNavMeshes={},this.scene=t,this.systems=t.sys,t.sys.settings.isBooted||this.systems.events.once("boot",this.boot,this)}boot(){this.systems.events.once("destroy",this.destroy,this)}init(){}start(){}destroy(){this.systems.events.off("boot",this.boot,this);const t=Object.values(this.phaserNavMeshes);this.phaserNavMeshes={},t.forEach(t=>t.destroy()),this.scene=void 0,this.systems=void 0}removeMesh(t){this.phaserNavMeshes[t]&&(this.phaserNavMeshes[t]=void 0)}buildMeshFromTiled(t,n,e=0){if(this.phaserNavMeshes[t])return console.warn(`NavMeshPlugin: a navmesh already exists with the given key: ${t}`),this.phaserNavMeshes[t];n&&0!==n.length||console.warn(`NavMeshPlugin: The given tilemap object layer is empty or undefined: ${n}`);const s=(n?n.objects:[]).map(t=>{const n=t.y,e=t.y+t.height,s=t.x,i=t.x+t.width;return[{x:s,y:n},{x:s,y:e},{x:i,y:e},{x:i,y:n}]}),i=new x(this,t,s,e);return this.phaserNavMeshes[t]=i,i}}}]).default});
//# sourceMappingURL=phaser-navmesh.min.js.map