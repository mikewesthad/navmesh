{"version":3,"sources":["webpack://PhaserNavMeshPlugin/webpack/universalModuleDefinition","webpack://PhaserNavMeshPlugin/webpack/bootstrap","webpack://PhaserNavMeshPlugin/C:/Users/mikewesthad/Documents/GitHub/phaser-navmesh/node_modules/javascript-astar/astar.js","webpack://PhaserNavMeshPlugin/external {\"root\":\"Phaser\",\"commonjs\":\"phaser\",\"commonjs2\":\"phaser\",\"amd\":\"phaser\"}","webpack://PhaserNavMeshPlugin/../../navmesh/src/math/vector-2.js","webpack://PhaserNavMeshPlugin/../../navmesh/src/navpoly.js","webpack://PhaserNavMeshPlugin/../../navmesh/src/navgraph.js","webpack://PhaserNavMeshPlugin/../../navmesh/src/utils.js","webpack://PhaserNavMeshPlugin/../../navmesh/src/channel.js","webpack://PhaserNavMeshPlugin/../../navmesh/src/math/line.js","webpack://PhaserNavMeshPlugin/../../navmesh/src/math/polygon.js","webpack://PhaserNavMeshPlugin/../../navmesh/src/index.js","webpack://PhaserNavMeshPlugin/../../navmesh/src/navmesh.js","webpack://PhaserNavMeshPlugin/./phaser-navmesh.js","webpack://PhaserNavMeshPlugin/./phaser-navmesh-plugin.js","webpack://PhaserNavMeshPlugin/./index.js"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","definition","undefined","apply","pathTo","node","curr","path","parent","unshift","astar","search","graph","start","end","options","cleanDirty","heuristic","heuristics","manhattan","closest","openHeap","BinaryHeap","f","closestNode","h","markDirty","push","size","currentNode","pop","closed","neighbors","il","length","neighbor","isWall","gScore","g","getCost","beenVisited","visited","rescoreElement","pos0","pos1","Math","abs","x","y","diagonal","D2","sqrt","d1","d2","min","cleanNode","Graph","gridIn","this","nodes","grid","row","GridNode","init","weight","scoreFunction","content","dirtyNodes","ret","toString","graphString","rowDebug","join","fromNeighbor","element","sinkDown","result","bubbleUp","remove","indexOf","parentN","elemScore","child1Score","child2N","child1N","swap","child1","child2","Vector2","_classCallCheck","v","atan2","dx","dy","NavPoly","id","polygon","navpoly_classCallCheck","edges","portals","centroid","calculateCentroid","boundingRadius","calculateRadius","points","point","contains","isPointOnEdge","vector_2","forEach","add","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","distance","err","return","_ref","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","pointOnSegment","navPolygon","centroidDistance","NavGraph","navPolygons","navgraph_classCallCheck","navPolygon1","navPolygon2","astar_default","a","navgraph","triarea2","b","ax","ay","almostEqual","value1","value2","errorMargin","arguments","angleDifference","PI","j","floor","areCollinear","line1","line2","area1","area2","src_channel","Channel","channel_classCallCheck","p1","p2","left","right","portalApex","portalLeft","portalRight","pts","apexIndex","leftIndex","rightIndex","equals","Line","x1","y1","x2","y2","line_classCallCheck","max","top","bottom","pointOnLine","Polygon","polygon_classCallCheck","math_line","first","last","inside","ix","iy","jx","jy","src","NavMesh","meshPolygonPoints","meshShrinkAmount","navmesh_classCallCheck","_meshShrinkAmount","newPolys","map","polyPoints","vectors","math_polygon","_navPolygons","navpoly","_calculateNeighbors","_graph","destroy","startPoint","endPoint","startPoly","endPoly","startDistance","Number","MAX_VALUE","endDistance","startVector","endVector","navPoly","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_projectPointToPolygon","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","astarPath","navHeuristic","channel","nextNavPolygon","portal","stringPull","lastPoint","phaserPath","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","newPoint","clone","otherNavPoly","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","edge","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","otherEdge","overlap","_getSegmentOverlap","_overlap","_slicedToArray","edgeStartAngle","angle","a1","a2","line","sort","noOverlap","singlePointOverlap","closestProjection","closestDistance","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","projectedPoint","_projectPointToEdge","l2","_distanceSquared","clamp","PhaserNavMesh","plugin","phaser_navmesh_classCallCheck","scene","debugGraphics","navMesh","PointClass","external_root_Phaser_commonjs_phaser_commonjs2_phaser_amd_phaser_default","Geom","Point","findPath","graphics","visible","clear","_this","_ref2","_ref2$drawCentroid","drawCentroid","_ref2$drawBounds","drawBounds","_ref2$drawNeighbors","drawNeighbors","_ref2$drawPortals","drawPortals","_ref2$palette","palette","getPolygons","poly","color","fillStyle","fillPoints","getPoints","fillCircle","lineStyle","strokeCircle","lineBetween","thickness","alpha","strokePoints","removeMesh","PhaserNavMeshPlugin","pluginManager","phaser_navmesh_plugin_classCallCheck","_possibleConstructorReturn","__proto__","getPrototypeOf","phaserNavMeshes","systems","sys","settings","isBooted","events","once","boot","Plugins","ScenePlugin","off","meshes","values","objectLayer","console","warn","polygons","objects","obj","height","width","mesh","phaser_navmesh","__webpack_exports__"],"mappings":"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","file":"phaser-navmesh.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"phaser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"phaser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserNavMeshPlugin\"] = factory(require(\"phaser\"));\n\telse\n\t\troot[\"PhaserNavMeshPlugin\"] = factory(root[\"Phaser\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","// javascript-astar 0.4.2\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n(function(definition) {\n  /* global module, define */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = definition();\n  } else if (typeof define === 'function' && define.amd) {\n    define([], definition);\n  } else {\n    var exports = definition();\n    window.astar = exports.astar;\n    window.Graph = exports.Graph;\n  }\n})(function() {\n\nfunction pathTo(node) {\n  var curr = node;\n  var path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function(node) {\n    return node.f;\n  });\n}\n\nvar astar = {\n  /**\n  * Perform an A* Search on a graph given a start and end node.\n  * @param {Graph} graph\n  * @param {GridNode} start\n  * @param {GridNode} end\n  * @param {Object} [options]\n  * @param {bool} [options.closest] Specifies whether to return the\n             path to the closest node if the target is unreachable.\n  * @param {Function} [options.heuristic] Heuristic function (see\n  *          astar.heuristics).\n  */\n  search: function(graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\n    var closest = options.closest || false;\n\n    var openHeap = getHeap();\n    var closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n    graph.markDirty(start);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\n        var beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function(pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function(pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\n    }\n  },\n  cleanNode: function(node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\n\n/**\n * A graph memory structure\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options]\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n */\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\n\nGraph.prototype.init = function() {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function() {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function(node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function(node) {\n  var ret = [];\n  var x = node.x;\n  var y = node.y;\n  var grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function() {\n  var graphString = [];\n  var nodes = this.grid;\n  for (var x = 0; x < nodes.length; x++) {\n    var rowDebug = [];\n    var row = nodes[x];\n    for (var y = 0; y < row.length; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function() {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function(fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function() {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function(node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function() {\n    return this.content.length;\n  },\n  rescoreElement: function(node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function(n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1;\n      var parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      }\n      // Found a parent that is less, no need to sink any further.\n      else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null;\n      var child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n};\n\nreturn {\n  astar: astar,\n  Graph: Graph\n};\n\n});","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","/**\r\n * Stripped down version of Phaser's Vector2 with just the functionality needed for navmeshes\r\n *\r\n * @export\r\n * @class Vector2\r\n */\r\nexport default class Vector2 {\r\n  constructor(x, y) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n  }\r\n\r\n  equals(v) {\r\n    return this.x === v.x && this.y === v.y;\r\n  }\r\n\r\n  angle(v) {\r\n    return Math.atan2(v.y - this.y, v.x - this.x);\r\n  }\r\n\r\n  distance(v) {\r\n    const dx = v.x - this.x;\r\n    const dy = v.y - this.y;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  add(v) {\r\n    this.x += v.x;\r\n    this.y += v.y;\r\n  }\r\n\r\n  subtract(v) {\r\n    this.x -= v.x;\r\n    this.y -= v.y;\r\n  }\r\n\r\n  clone() {\r\n    return new Vector2(this.x, this.y);\r\n  }\r\n}\r\n","import Vector2 from \"./math/vector-2\";\r\n\r\n/**\r\n * A class that represents a navigable polygon with a navmesh. It is built on top of a\r\n * {@link Polygon}. It implements the properties and fields that javascript-astar needs - weight,\r\n * toString, isWall and getCost. See GPS test from astar repo for structure:\r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavPoly\r\n */\r\nexport default class NavPoly {\r\n  /**\r\n   * Creates an instance of NavPoly.\r\n   * @param {number} id\r\n   * @param {Polygon} polygon\r\n   *\r\n   * @memberof NavPoly\r\n   */\r\n  constructor(id, polygon) {\r\n    this.id = id;\r\n    this.polygon = polygon;\r\n    this.edges = polygon.edges;\r\n    this.neighbors = [];\r\n    this.portals = [];\r\n    this.centroid = this.calculateCentroid();\r\n    this.boundingRadius = this.calculateRadius();\r\n\r\n    this.weight = 1; // jsastar property\r\n  }\r\n\r\n  /**\r\n   * Returns an array of points that form the polygon.\r\n   *\r\n   * @returns {Vector2[]}\r\n   * @memberof NavPoly\r\n   */\r\n  getPoints() {\r\n    return this.polygon.points;\r\n  }\r\n\r\n  /**\r\n   * Check if the given point-like object is within the polygon\r\n   *\r\n   * @param {object} point Object of the form {x, y}\r\n   * @returns {boolean}\r\n   * @memberof NavPoly\r\n   */\r\n  contains(point) {\r\n    // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:\r\n    // check numerical stability here. It would also be good to optimize this for different shapes.\r\n    return this.polygon.contains(point.x, point.y) || this.isPointOnEdge(point);\r\n  }\r\n\r\n  /**\r\n   * Only rectangles are supported, so this calculation works, but this is not actually the centroid\r\n   * calculation for a polygon. This is just the average of the vertices - proper centroid of a\r\n   * polygon factors in the area.\r\n   *\r\n   * @returns {Vector2}\r\n   * @memberof NavPoly\r\n   */\r\n  calculateCentroid() {\r\n    const centroid = new Vector2(0, 0);\r\n    const length = this.polygon.points.length;\r\n    this.polygon.points.forEach(p => centroid.add(p));\r\n    centroid.x /= length;\r\n    centroid.y /= length;\r\n    return centroid;\r\n  }\r\n\r\n  /**\r\n   * Calculate the radius of a circle that circumscribes the polygon.\r\n   *\r\n   * @returns {number}\r\n   * @memberof NavPoly\r\n   */\r\n  calculateRadius() {\r\n    let boundingRadius = 0;\r\n    for (const point of this.polygon.points) {\r\n      const d = this.centroid.distance(point);\r\n      if (d > boundingRadius) boundingRadius = d;\r\n    }\r\n    return boundingRadius;\r\n  }\r\n\r\n  /**\r\n   * Check if the given point-like object is on one of the edges of the polygon.\r\n   *\r\n   * @param {object} Point-like object in the form { x, y }\r\n   * @returns {boolean}\r\n   * @memberof NavPoly\r\n   */\r\n  isPointOnEdge({ x, y }) {\r\n    for (const edge of this.edges) {\r\n      if (edge.pointOnSegment(x, y)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  destroy() {\r\n    this.neighbors = [];\r\n    this.portals = [];\r\n  }\r\n\r\n  // jsastar methods\r\n  toString() {\r\n    return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n  }\r\n  isWall() {\r\n    return this.weight === 0;\r\n  }\r\n  centroidDistance(navPolygon) {\r\n    return this.centroid.distance(navPolygon.centroid);\r\n  }\r\n  getCost(navPolygon) {\r\n    return this.centroidDistance(navPolygon);\r\n  }\r\n}\r\n","import jsastar from \"javascript-astar\";\r\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph\r\n * @private\r\n */\r\nclass NavGraph {\r\n  constructor(navPolygons) {\r\n    this.nodes = navPolygons;\r\n    this.init();\r\n  }\r\n\r\n  neighbors(navPolygon) {\r\n    return navPolygon.neighbors;\r\n  }\r\n\r\n  navHeuristic(navPolygon1, navPolygon2) {\r\n    return navPolygon1.centroidDistance(navPolygon2);\r\n  }\r\n\r\n  destroy() {\r\n    this.cleanDirty();\r\n    this.nodes = [];\r\n  }\r\n}\r\n\r\nNavGraph.prototype.init = jsastar.Graph.prototype.init;\r\nNavGraph.prototype.cleanDirty = jsastar.Graph.prototype.cleanDirty;\r\nNavGraph.prototype.markDirty = jsastar.Graph.prototype.markDirty;\r\n\r\nexport default NavGraph;\r\n","/**\r\n * Twice the area of the triangle formed by a, b and c\r\n * @returns {number}\r\n * @private\r\n */\r\nexport function triarea2(a, b, c) {\r\n  const ax = b.x - a.x;\r\n  const ay = b.y - a.y;\r\n  const bx = c.x - a.x;\r\n  const by = c.y - a.y;\r\n  return bx * ay - ax * by;\r\n}\r\n\r\n/**\r\n * Clamp value between min and max\r\n * @returns {number}\r\n * @private\r\n */\r\nexport function clamp(value, min, max) {\r\n  if (value < min) value = min;\r\n  if (value > max) value = max;\r\n  return value;\r\n}\r\n\r\n/**\r\n * Check if two values within a small margin of one another\r\n * @returns {boolean}\r\n * @private\r\n */\r\nexport function almostEqual(value1, value2, errorMargin = 0.0001) {\r\n  if (Math.abs(value1 - value2) <= errorMargin) return true;\r\n  else return false;\r\n}\r\n\r\n/**\r\n * Find the smallest angle difference between two angles\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n * @returns {number}\r\n * @private\r\n */\r\nexport function angleDifference(x, y) {\r\n  let a = x - y;\r\n  const i = a + Math.PI;\r\n  const j = Math.PI * 2;\r\n  a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n  a -= Math.PI;\r\n  return a;\r\n}\r\n\r\n/**\r\n * Check if two lines are collinear (within a marign)\r\n * @returns {boolean}\r\n * @private\r\n */\r\nexport function areCollinear(line1, line2, errorMargin = 0.0001) {\r\n  // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n  // by their points\r\n  const area1 = triarea2(line1.start, line1.end, line2.start);\r\n  const area2 = triarea2(line1.start, line1.end, line2.end);\r\n  if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n    return true;\r\n  } else return false;\r\n}\r\n","// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\nimport { triarea2 } from \"./utils\";\r\n\r\n/**\r\n * @private\r\n */\r\nclass Channel {\r\n  constructor() {\r\n    this.portals = [];\r\n  }\r\n\r\n  push(p1, p2 = null) {\r\n    if (p2 === null) p2 = p1;\r\n    this.portals.push({\r\n      left: p1,\r\n      right: p2\r\n    });\r\n  }\r\n\r\n  stringPull() {\r\n    var portals = this.portals;\r\n    var pts = [];\r\n    // Init scan state\r\n    var portalApex, portalLeft, portalRight;\r\n    var apexIndex = 0,\r\n      leftIndex = 0,\r\n      rightIndex = 0;\r\n\r\n    portalApex = portals[0].left;\r\n    portalLeft = portals[0].left;\r\n    portalRight = portals[0].right;\r\n\r\n    // Add start point.\r\n    pts.push(portalApex);\r\n\r\n    for (var i = 1; i < portals.length; i++) {\r\n      // Find the next portal vertices\r\n      var left = portals[i].left;\r\n      var right = portals[i].right;\r\n\r\n      // Update right vertex.\r\n      if (triarea2(portalApex, portalRight, right) <= 0.0) {\r\n        if (portalApex.equals(portalRight) || triarea2(portalApex, portalLeft, right) > 0.0) {\r\n          // Tighten the funnel.\r\n          portalRight = right;\r\n          rightIndex = i;\r\n        } else {\r\n          // Right vertex just crossed over the left vertex, so the left vertex should\r\n          // now be part of the path.\r\n          pts.push(portalLeft);\r\n\r\n          // Restart scan from portal left point.\r\n\r\n          // Make current left the new apex.\r\n          portalApex = portalLeft;\r\n          apexIndex = leftIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Update left vertex.\r\n      if (triarea2(portalApex, portalLeft, left) >= 0.0) {\r\n        if (portalApex.equals(portalLeft) || triarea2(portalApex, portalRight, left) < 0.0) {\r\n          // Tighten the funnel.\r\n          portalLeft = left;\r\n          leftIndex = i;\r\n        } else {\r\n          // Left vertex just crossed over the right vertex, so the right vertex should\r\n          // now be part of the path\r\n          pts.push(portalRight);\r\n\r\n          // Restart scan from portal right point.\r\n\r\n          // Make current right the new apex.\r\n          portalApex = portalRight;\r\n          apexIndex = rightIndex;\r\n          // Reset portal\r\n          portalLeft = portalApex;\r\n          portalRight = portalApex;\r\n          leftIndex = apexIndex;\r\n          rightIndex = apexIndex;\r\n          // Restart scan\r\n          i = apexIndex;\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\r\n      // Append last point to path.\r\n      pts.push(portals[portals.length - 1].left);\r\n    }\r\n\r\n    this.path = pts;\r\n    return pts;\r\n  }\r\n}\r\n\r\nexport default Channel;\r\n","import Vector2 from \"./vector-2\";\r\n\r\n/**\r\n * Stripped down version of Phaser's Line with just the functionality needed for navmeshes\r\n *\r\n * @export\r\n * @class Line\r\n */\r\nexport default class Line {\r\n  constructor(x1, y1, x2, y2) {\r\n    this.start = new Vector2(x1, y1);\r\n    this.end = new Vector2(x2, y2);\r\n\r\n    this.left = Math.min(x1, x2);\r\n    this.right = Math.max(x1, x2);\r\n    this.top = Math.min(y1, y2);\r\n    this.bottom = Math.max(y1, y2);\r\n  }\r\n\r\n  pointOnSegment(x, y) {\r\n    return (\r\n      x >= this.left &&\r\n      x <= this.right &&\r\n      y >= this.top &&\r\n      y <= this.bottom &&\r\n      this.pointOnLine(x, y)\r\n    );\r\n  }\r\n\r\n  pointOnLine(x, y) {\r\n    // Compare slope of line start -> xy to line start -> line end\r\n    return (x - this.left) * (this.bottom - this.top) === (this.right - this.left) * (y - this.top);\r\n  }\r\n}\r\n","import Line from \"./line\";\r\n\r\n/**\r\n * Stripped down version of Phaser's Polygon with just the functionality needed for navmeshes\r\n *\r\n * @export\r\n * @class Polygon\r\n */\r\nexport default class Polygon {\r\n  constructor(points, closed = true) {\r\n    this.points = points;\r\n    this.edges = [];\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n      const p1 = points[i - 1];\r\n      const p2 = points[i];\r\n      this.edges.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n    }\r\n    if (closed) {\r\n      const first = points[0];\r\n      const last = points[points.length - 1];\r\n      this.edges.push(new Line(first.x, first.y, last.x, last.y));\r\n    }\r\n  }\r\n\r\n  contains(x, y) {\r\n    let inside = false;\r\n\r\n    for (let i = -1, j = this.points.length - 1; ++i < this.points.length; j = i) {\r\n      const ix = this.points[i].x;\r\n      const iy = this.points[i].y;\r\n\r\n      const jx = this.points[j].x;\r\n      const jy = this.points[j].y;\r\n\r\n      if (\r\n        ((iy <= y && y < jy) || (jy <= y && y < iy)) &&\r\n        x < ((jx - ix) * (y - iy)) / (jy - iy) + ix\r\n      ) {\r\n        inside = !inside;\r\n      }\r\n    }\r\n\r\n    return inside;\r\n  }\r\n}\r\n","import NavMesh from \"./navmesh\";\r\n\r\nexport default NavMesh;\r\n","import jsastar from \"javascript-astar\";\r\nimport NavPoly from \"./navpoly\";\r\nimport NavGraph from \"./navgraph\";\r\nimport Channel from \"./channel\";\r\nimport { angleDifference, areCollinear, clamp } from \"./utils\";\r\nimport Vector2 from \"./math/vector-2\";\r\nimport Line from \"./math/line\";\r\nimport Polygon from \"./math/polygon\";\r\n\r\n/**\r\n * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the\r\n * mesh can be asked for a path from one point to another point. Some internal terminology usage:\r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n *\r\n * @class NavMesh\r\n */\r\nexport default class NavMesh {\r\n  /**\r\n   * Creates an instance of NavMesh.\r\n   * @param {object[][]} meshPolygonPoints Array where each element is an array of point-like\r\n   * objects that defines a polygon.\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been\r\n   * shrunk around obstacles (a.k.a the amount obstacles have been expanded)\r\n   * @memberof NavMesh\r\n   */\r\n  constructor(meshPolygonPoints, meshShrinkAmount = 0) {\r\n    this._meshShrinkAmount = meshShrinkAmount;\r\n\r\n    const newPolys = meshPolygonPoints.map(polyPoints => {\r\n      const vectors = polyPoints.map(p => new Vector2(p.x, p.y));\r\n      return new Polygon(vectors);\r\n    });\r\n\r\n    this._navPolygons = newPolys.map((polygon, i) => new NavPoly(i, polygon));\r\n\r\n    this._calculateNeighbors();\r\n\r\n    // Astar graph of connections between polygons\r\n    this._graph = new NavGraph(this._navPolygons);\r\n  }\r\n\r\n  /**\r\n   * Get the NavPolys that are in this navmesh.\r\n   *\r\n   * @returns {NavPoly[]}\r\n   * @memberof NavMesh\r\n   */\r\n  getPolygons() {\r\n    return this._navPolygons;\r\n  }\r\n\r\n  /**\r\n   * Cleanup method to remove references.\r\n   *\r\n   * @memberof NavMesh\r\n   */\r\n  destroy() {\r\n    this._graph.destroy();\r\n    for (const poly of this._navPolygons) poly.destroy();\r\n    this._navPolygons = [];\r\n  }\r\n\r\n  /**\r\n   * Find a path from the start point to the end point using this nav mesh.\r\n   *\r\n   * @param {object} startPoint A point-like object in the form {x, y}\r\n   * @param {object} endPoint A point-like object in the form {x, y}\r\n   * @returns {Vector2[]|null} An array of points if a path is found, or null if no path\r\n   *\r\n   * @memberof NavMesh\r\n   */\r\n  findPath(startPoint, endPoint) {\r\n    let startPoly = null;\r\n    let endPoly = null;\r\n    let startDistance = Number.MAX_VALUE;\r\n    let endDistance = Number.MAX_VALUE;\r\n    let d, r;\r\n    const startVector = new Vector2(startPoint.x, startPoint.y);\r\n    const endVector = new Vector2(endPoint.x, endPoint.y);\r\n\r\n    // Find the closest poly for the starting and ending point\r\n    for (const navPoly of this._navPolygons) {\r\n      r = navPoly.boundingRadius;\r\n      // Start\r\n      d = navPoly.centroid.distance(startVector);\r\n      if (d <= startDistance && d <= r && navPoly.contains(startVector)) {\r\n        startPoly = navPoly;\r\n        startDistance = d;\r\n      }\r\n      // End\r\n      d = navPoly.centroid.distance(endVector);\r\n      if (d <= endDistance && d <= r && navPoly.contains(endVector)) {\r\n        endPoly = navPoly;\r\n        endDistance = d;\r\n      }\r\n    }\r\n\r\n    // If the start point wasn't inside a polygon, run a more liberal check that allows a point\r\n    // to be within meshShrinkAmount radius of a polygon\r\n    if (!startPoly && this._meshShrinkAmount > 0) {\r\n      for (const navPoly of this._navPolygons) {\r\n        // Check if point is within bounding circle to avoid extra projection calculations\r\n        r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n        d = navPoly.centroid.distance(startVector);\r\n        if (d <= r) {\r\n          // Check if projected point is within range of a polgyon and is closer than the\r\n          // previous point\r\n          const { distance } = this._projectPointToPolygon(startVector, navPoly);\r\n          if (distance <= this._meshShrinkAmount && distance < startDistance) {\r\n            startPoly = navPoly;\r\n            startDistance = distance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Same check as above, but for the end point\r\n    if (!endPoly && this._meshShrinkAmount > 0) {\r\n      for (const navPoly of this._navPolygons) {\r\n        r = navPoly.boundingRadius + this._meshShrinkAmount;\r\n        d = navPoly.centroid.distance(endVector);\r\n        if (d <= r) {\r\n          const { distance } = this._projectPointToPolygon(endVector, navPoly);\r\n          if (distance <= this._meshShrinkAmount && distance < endDistance) {\r\n            endPoly = navPoly;\r\n            endDistance = distance;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // No matching polygons locations for the start or end, so no path found\r\n    if (!startPoly || !endPoly) return null;\r\n\r\n    // If the start and end polygons are the same, return a direct path\r\n    if (startPoly === endPoly) return [startVector, endVector];\r\n\r\n    // Search!\r\n    const astarPath = jsastar.astar.search(this._graph, startPoly, endPoly, {\r\n      heuristic: this._graph.navHeuristic\r\n    });\r\n\r\n    // While the start and end polygons may be valid, no path between them\r\n    if (astarPath.length === 0) return null;\r\n\r\n    // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n    astarPath.unshift(startPoly);\r\n\r\n    // We have a path, so now time for the funnel algorithm\r\n    const channel = new Channel();\r\n    channel.push(startVector);\r\n    for (let i = 0; i < astarPath.length - 1; i++) {\r\n      const navPolygon = astarPath[i];\r\n      const nextNavPolygon = astarPath[i + 1];\r\n\r\n      // Find the portal\r\n      let portal = null;\r\n      for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n        if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n          portal = navPolygon.portals[i];\r\n        }\r\n      }\r\n\r\n      // Push the portal vertices into the channel\r\n      channel.push(portal.start, portal.end);\r\n    }\r\n    channel.push(endVector);\r\n\r\n    // Pull a string along the channel to run the funnel\r\n    channel.stringPull();\r\n\r\n    // Clone path, excluding duplicates\r\n    let lastPoint = null;\r\n    const phaserPath = [];\r\n    for (const p of channel.path) {\r\n      const newPoint = p.clone();\r\n      if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);\r\n      lastPoint = newPoint;\r\n    }\r\n\r\n    return phaserPath;\r\n  }\r\n\r\n  _calculateNeighbors() {\r\n    // Fill out the neighbor information for each navpoly\r\n    for (let i = 0; i < this._navPolygons.length; i++) {\r\n      const navPoly = this._navPolygons[i];\r\n\r\n      for (let j = i + 1; j < this._navPolygons.length; j++) {\r\n        const otherNavPoly = this._navPolygons[j];\r\n\r\n        // Check if the other navpoly is within range to touch\r\n        const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n        if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius) continue;\r\n\r\n        // The are in range, so check each edge pairing\r\n        for (const edge of navPoly.edges) {\r\n          for (const otherEdge of otherNavPoly.edges) {\r\n            // If edges aren't collinear, not an option for connecting navpolys\r\n            if (!areCollinear(edge, otherEdge)) continue;\r\n\r\n            // If they are collinear, check if they overlap\r\n            const overlap = this._getSegmentOverlap(edge, otherEdge);\r\n            if (!overlap) continue;\r\n\r\n            // Connections are symmetric!\r\n            navPoly.neighbors.push(otherNavPoly);\r\n            otherNavPoly.neighbors.push(navPoly);\r\n\r\n            // Calculate the portal between the two polygons - this needs to be in\r\n            // counter-clockwise order, relative to each polygon\r\n            const [p1, p2] = overlap;\r\n            let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n            let a1 = navPoly.centroid.angle(overlap[0]);\r\n            let a2 = navPoly.centroid.angle(overlap[1]);\r\n            let d1 = angleDifference(edgeStartAngle, a1);\r\n            let d2 = angleDifference(edgeStartAngle, a2);\r\n            if (d1 < d2) {\r\n              navPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n            } else {\r\n              navPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\r\n            }\r\n\r\n            edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n            a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n            a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n            d1 = angleDifference(edgeStartAngle, a1);\r\n            d2 = angleDifference(edgeStartAngle, a2);\r\n            if (d1 < d2) {\r\n              otherNavPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));\r\n            } else {\r\n              otherNavPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));\r\n            }\r\n\r\n            // Two convex polygons shouldn't be connected more than once! (Unless\r\n            // there are unnecessary vertices...)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check two collinear line segments to see if they overlap by sorting the points.\r\n  // Algorithm source: http://stackoverflow.com/a/17152247\r\n  _getSegmentOverlap(line1, line2) {\r\n    const points = [\r\n      { line: line1, point: line1.start },\r\n      { line: line1, point: line1.end },\r\n      { line: line2, point: line2.start },\r\n      { line: line2, point: line2.end }\r\n    ];\r\n    points.sort(function(a, b) {\r\n      if (a.point.x < b.point.x) return -1;\r\n      else if (a.point.x > b.point.x) return 1;\r\n      else {\r\n        if (a.point.y < b.point.y) return -1;\r\n        else if (a.point.y > b.point.y) return 1;\r\n        else return 0;\r\n      }\r\n    });\r\n    // If the first two points in the array come from the same line, no overlap\r\n    const noOverlap = points[0].line === points[1].line;\r\n    // If the two middle points in the array are the same coordinates, then there is a\r\n    // single point of overlap.\r\n    const singlePointOverlap = points[1].point.equals(points[2].point);\r\n    if (noOverlap || singlePointOverlap) return null;\r\n    else return [points[1].point, points[2].point];\r\n  }\r\n\r\n  /**\r\n   * Project a point onto a polygon in the shortest distance possible.\r\n   *\r\n   * @param {Phaser.Point} point The point to project\r\n   * @param {NavPoly} navPoly The navigation polygon to test against\r\n   * @returns {{point: Phaser.Point, distance: number}}\r\n   *\r\n   * @private\r\n   * @memberof NavMesh\r\n   */\r\n  _projectPointToPolygon(point, navPoly) {\r\n    let closestProjection = null;\r\n    let closestDistance = Number.MAX_VALUE;\r\n    for (const edge of navPoly.edges) {\r\n      const projectedPoint = this._projectPointToEdge(point, edge);\r\n      const d = point.distance(projectedPoint);\r\n      if (closestProjection === null || d < closestDistance) {\r\n        closestDistance = d;\r\n        closestProjection = projectedPoint;\r\n      }\r\n    }\r\n    return { point: closestProjection, distance: closestDistance };\r\n  }\r\n\r\n  _distanceSquared(a, b) {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    return dx * dx + dy * dy;\r\n  }\r\n\r\n  // Project a point onto a line segment\r\n  // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n  _projectPointToEdge(point, line) {\r\n    const a = line.start;\r\n    const b = line.end;\r\n    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n    // where our point lies on the line by solving for t:\r\n    //  t = [(p-a) . (b-a)] / |b-a|^2\r\n    const l2 = this._distanceSquared(a, b);\r\n    let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n    // We clamp t from [0,1] to handle points outside the segment vw.\r\n    t = clamp(t, 0, 1);\r\n    // Project onto the segment\r\n    const p = new Vector2(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\r\n    return p;\r\n  }\r\n}\r\n","import NavMesh from \"navmesh/src\"; // import the source - not the dist - no need to double build\r\nimport Phaser from \"phaser\";\r\n\r\n/**\r\n * A wrapper around {@link NavMesh} for Phaser 3. Create instances of this class from\r\n * {@link PhaserNavMeshPlugin}. This is the workhorse that represents a navigation mesh built from a\r\n * series of polygons. Once built, the mesh can be asked for a path from one point to another point.\r\n *\r\n * Compared to {@link NavMesh}, this adds visual debugging capabilities and converts paths to\r\n * Phaser-compatible point instances.\r\n *\r\n * @export\r\n * @class PhaserNavMesh\r\n */\r\nexport default class PhaserNavMesh {\r\n  /**\r\n   * Creates an instance of PhaserNavMesh.\r\n   * @param {PhaserNavMeshPlugin} plugin The plugin that owns this mesh.\r\n   * @param {string} key The key the mesh is stored under within the plugin.\r\n   * @param {object[][]} meshPolygonPoints Array where each element is an array of point-like\r\n   * objects that defines a polygon.\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been shrunk\r\n   * around obstacles (a.k.a the amount obstacles have been expanded)\r\n   * @memberof PhaserNavMesh\r\n   */\r\n  constructor(plugin, key, meshPolygonPoints, meshShrinkAmount = 0) {\r\n    this.key = key;\r\n    this.plugin = plugin;\r\n    this.scene = plugin.scene;\r\n    this.debugGraphics = null;\r\n    this.navMesh = new NavMesh(meshPolygonPoints, meshShrinkAmount);\r\n  }\r\n\r\n  /**\r\n   * See {@link NavMesh#findPath}. This implements the same functionality, except that the returned path\r\n   * is converted to Phaser-compatible points.\r\n   *\r\n   * @param {object} startPoint A point-like object in the form {x, y}\r\n   * @param {object} endPoint A point-like object in the form {x, y}\r\n   * @param {class} [PointClass=Phaser.Geom.Point]\r\n   * @returns {object[]|null} An array of points if a path is found, or null if no path\r\n   * @memberof PhaserNavMesh\r\n   */\r\n  findPath(startPoint, endPoint, PointClass = Phaser.Geom.Point) {\r\n    const path = this.navMesh.findPath(startPoint, endPoint);\r\n    return path ? path.map(({ x, y }) => new PointClass(x, y)) : path;\r\n  }\r\n\r\n  /**\r\n   * Enable the debug drawing graphics. If no graphics object is providied, a new instance will be\r\n   * created.\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} [graphics] An optional graphics object for the mesh to use\r\n   * for debug drawing. Note, the mesh will destroy this graphics object when the mesh is destroyed.\r\n   * @returns {Phaser.GameObjects.Graphics} The graphics object this mesh uses.\r\n   * @memberof PhaserNavMesh\r\n   */\r\n  enableDebug(graphics) {\r\n    if (!graphics && !this.debugGraphics) {\r\n      this.debugGraphics = this.scene.add.graphics();\r\n    } else if (graphics) {\r\n      if (this.debugGraphics) this.debugGraphics.destroy();\r\n      this.debugGraphics = graphics;\r\n    }\r\n\r\n    this.debugGraphics.visible = true;\r\n\r\n    return this.debugGraphics;\r\n  }\r\n\r\n  /**\r\n   * Hide the debug graphics, but don't destroy it.\r\n   *\r\n   * @memberof PhaserNavMesh\r\n   */\r\n  disableDebug() {\r\n    if (this.debugGraphics) this.debugGraphics.visible = false;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the debug graphics object is enabled and visible.\r\n   *\r\n   * @returns {boolean}\r\n   * @memberof PhaserNavMesh\r\n   */\r\n  isDebugEnabled() {\r\n    return this.debugGraphics && this.debugGraphics.visible;\r\n  }\r\n\r\n  /**\r\n   * Clear the debug graphics.\r\n   *\r\n   * @memberof PhaserNavMesh\r\n   */\r\n  debugDrawClear() {\r\n    if (this.debugGraphics) this.debugGraphics.clear();\r\n  }\r\n\r\n  /**\r\n   * Visualize the polygons in the navmesh by drawing them to the debug graphics.\r\n   *\r\n   * @param {object} options\r\n   * @param {boolean} [options.drawCentroid=true] For each polygon, show the approx centroid\r\n   * @param {boolean} [options.drawBounds=false] For each polygon, show the bounding radius\r\n   * @param {boolean} [options.drawNeighbors=true] For each polygon, show the connections to\r\n   * neighbors\r\n   * @param {boolean} [options.drawPortals=true] For each polygon, show the portal edges\r\n   * @param {number[]} [options.palette=[0x00a0b0, 0x6a4a3c, 0xcc333f, 0xeb6841, 0xedc951]] An array\r\n   * of Phaser-compatible format colors to use when drawing the individual polygons. The first poly\r\n   * uses the first color, the second poly uses the second color, etc. \r\n   */\r\n  debugDrawMesh({\r\n    drawCentroid = true,\r\n    drawBounds = false,\r\n    drawNeighbors = true,\r\n    drawPortals = true,\r\n    palette = [0x00a0b0, 0x6a4a3c, 0xcc333f, 0xeb6841, 0xedc951]\r\n  } = {}) {\r\n    if (!this.debugGraphics) return;\r\n\r\n    const navPolys = this.navMesh.getPolygons();\r\n\r\n    navPolys.forEach(poly => {\r\n      const color = palette[poly.id % palette.length];\r\n      this.debugGraphics.fillStyle(color);\r\n      this.debugGraphics.fillPoints(poly.getPoints(), true);\r\n\r\n      if (drawCentroid) {\r\n        this.debugGraphics.fillStyle(0x000000);\r\n        this.debugGraphics.fillCircle(poly.centroid.x, poly.centroid.y, 4);\r\n      }\r\n\r\n      if (drawBounds) {\r\n        this.debugGraphics.lineStyle(1, 0xffffff);\r\n        this.debugGraphics.strokeCircle(poly.centroid.x, poly.centroid.y, poly.boundingRadius);\r\n      }\r\n\r\n      if (drawNeighbors) {\r\n        this.debugGraphics.lineStyle(2, 0x000000);\r\n        poly.neighbors.forEach(n => {\r\n          this.debugGraphics.lineBetween(\r\n            poly.centroid.x,\r\n            poly.centroid.y,\r\n            n.centroid.x,\r\n            n.centroid.y\r\n          );\r\n        });\r\n      }\r\n\r\n      if (drawPortals) {\r\n        this.debugGraphics.lineStyle(10, 0x000000);\r\n        poly.portals.forEach(portal =>\r\n          this.debugGraphics.lineBetween(portal.start.x, portal.start.y, portal.end.x, portal.end.y)\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Visualize a path (array of points) on the debug graphics.\r\n   *\r\n   * @param {object[]} path Array of point-like objects in the form {x, y} \r\n   * @param {number} [color=0x00FF00]\r\n   * @param {number} [thickness=10]\r\n   * @param {number} [alpha=1]\r\n   */\r\n  debugDrawPath(path, color = 0x00ff00, thickness = 10, alpha = 1) {\r\n    if (!this.debugGraphics) return;\r\n\r\n    if (path && path.length) {\r\n      // Draw line for path\r\n      this.debugGraphics.lineStyle(thickness, color, alpha);\r\n      this.debugGraphics.strokePoints(path);\r\n\r\n      // Draw circle at start and end of path\r\n      this.debugGraphics.fillStyle(color, alpha);\r\n      const d = 1.2 * thickness;\r\n      this.debugGraphics.fillCircle(path[0].x, path[0].y, d, d);\r\n\r\n      if (path.length > 1) {\r\n        const lastPoint = path[path.length - 1];\r\n        this.debugGraphics.fillCircle(lastPoint.x, lastPoint.y, d, d);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy the mesh, kill the debug graphic and unregister itself with the plugin.\r\n   *\r\n   * @memberof PhaserNavMesh\r\n   */\r\n  destroy() {\r\n    if (this.navMesh) this.navMesh.destroy();\r\n    if (this.debugGraphics) this.debugGraphics.destroy();\r\n    this.plugin.removeMesh(this.key);\r\n    this.navMesh = undefined;\r\n    this.debugGraphics = undefined;\r\n    this.plugin = undefined;\r\n    this.scene = undefined;\r\n  }\r\n}\r\n","import Phaser from \"phaser\";\r\nimport PhaserNavMesh from \"./phaser-navmesh\";\r\n\r\n/**\r\n * This class can create navigation meshes for use in Phaser 3. The navmeshes can be constructed\r\n * from convex polygons embedded in a Tiled map. The class that conforms to Phaser 3's plugin\r\n * structure.\r\n *\r\n * @export\r\n * @class PhaserNavMeshPlugin\r\n */\r\nexport default class PhaserNavMeshPlugin extends Phaser.Plugins.ScenePlugin {\r\n  constructor(scene, pluginManager) {\r\n    super(scene, pluginManager);\r\n\r\n    this.phaserNavMeshes = {};\r\n    this.scene = scene;\r\n    this.systems = scene.sys;\r\n\r\n    if (!scene.sys.settings.isBooted) this.systems.events.once(\"boot\", this.boot, this);\r\n  }\r\n\r\n  /**\r\n   * Phaser.Scene lifecycle event\r\n   *\r\n   * @memberof PhaserNavMeshPlugin\r\n   */\r\n  boot() {\r\n    const emitter = this.systems.events;\r\n    emitter.once(\"destroy\", this.destroy, this);\r\n  }\r\n\r\n  /**\r\n   * Phaser.Scene lifecycle event - noop in this plugin, but still required.\r\n   *\r\n   * @memberof PhaserNavMeshPlugin\r\n   */\r\n  init() {}\r\n\r\n  /**\r\n   * Phaser.Scene lifecycle event - noop in this plugin, but still required.\r\n   *\r\n   * @memberof PhaserNavMeshPlugin\r\n   */\r\n  start() {}\r\n\r\n  /**\r\n   * Phaser.Scene lifecycle event - will destroy all navmeshes created.\r\n   *\r\n   * @memberof PhaserNavMeshPlugin\r\n   */\r\n  destroy() {\r\n    this.systems.events.off(\"boot\", this.boot, this);\r\n    const meshes = Object.values(this.phaserNavMeshes);\r\n    this.phaserNavMeshes = [];\r\n    meshes.forEach(m => m.destroy());\r\n    this.scene = undefined;\r\n    this.systems = undefined;\r\n  }\r\n\r\n  /**\r\n   * Destroy a navmesh and remove it from the plugin\r\n   *\r\n   * @param {string} key\r\n   * @memberof PhaserNavMeshPlugin\r\n   */\r\n  removeMesh(key) {\r\n    if (this.phaserNavMeshes[key]) {\r\n      this.phaserNavMeshes[key].destroy();\r\n      this.phaserNavMeshes[key] = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load a navmesh from Tiled. Currently assumes that the polygons are squares! Does not support\r\n   * tilemap layer scaling, rotation or position.\r\n   *\r\n   * @param {string} key Key to use when storign this navmesh within the plugin.\r\n   * @param {Phaser.Tilemaps.ObjectLayer} objectLayer The ObjectLayer from a tilemap that contains\r\n   * the polygons that make up the navmesh.\r\n   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been shrunk\r\n   * around obstacles (a.k.a the amount obstacles have been expanded)\r\n   * @returns {PhaserNavMesh}\r\n   * @memberof PhaserNavMeshPlugin\r\n   */\r\n  buildMeshFromTiled(key, objectLayer, meshShrinkAmount = 0) {\r\n    if (this.phaserNavMeshes[key]) {\r\n      console.warn(`NavMeshPlugin: a navmesh already exists with the given key: ${key}`);\r\n      return this.phaserNavMeshes[key];\r\n    }\r\n\r\n    if (!objectLayer || objectLayer.length === 0) {\r\n      console.warn(\r\n        `NavMeshPlugin: The given tilemap object layer is empty or undefined: ${objectLayer}`\r\n      );\r\n    }\r\n\r\n    // Load up the object layer\r\n    const objects = objectLayer ? objectLayer.objects : [];\r\n\r\n    // Loop over the objects and construct a polygon - assumes a rectangle for now!\r\n    // TODO: support layer position, scale, rotation\r\n    const polygons = objects.map(obj => {\r\n      const top = obj.y;\r\n      const bottom = obj.y + obj.height;\r\n      const left = obj.x;\r\n      const right = obj.x + obj.width;\r\n      return [\r\n        { x: left, y: top },\r\n        { x: left, y: bottom },\r\n        { x: right, y: bottom },\r\n        { x: right, y: top }\r\n      ];\r\n    });\r\n\r\n    const mesh = new PhaserNavMesh(this, key, polygons, meshShrinkAmount);\r\n\r\n    this.phaserNavMeshes[key] = mesh;\r\n\r\n    return mesh;\r\n  }\r\n}\r\n","import PhaserNavMeshPlugin from \"./phaser-navmesh-plugin\";\r\nimport PhaserNavMesh from \"./phaser-navmesh\";\r\n\r\nexport default PhaserNavMeshPlugin;\r\nexport { PhaserNavMesh };\r\n"],"sourceRoot":""}