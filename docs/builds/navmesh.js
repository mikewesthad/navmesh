/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["NavMesh"] = factory();
	else
		root["NavMesh"] = factory();
})((typeof self !== "undefined" ? self : this), function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../../node_modules/javascript-astar/astar.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/javascript-astar/astar.js ***!
  \*******************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// javascript-astar 0.4.2\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n(function(definition) {\n  /* global module, define */\n  if ( true && typeof module.exports === 'object') {\n    module.exports = definition();\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var exports; }\n})(function() {\n\nfunction pathTo(node) {\n  var curr = node;\n  var path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function(node) {\n    return node.f;\n  });\n}\n\nvar astar = {\n  /**\n  * Perform an A* Search on a graph given a start and end node.\n  * @param {Graph} graph\n  * @param {GridNode} start\n  * @param {GridNode} end\n  * @param {Object} [options]\n  * @param {bool} [options.closest] Specifies whether to return the\n             path to the closest node if the target is unreachable.\n  * @param {Function} [options.heuristic] Heuristic function (see\n  *          astar.heuristics).\n  */\n  search: function(graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\n    var closest = options.closest || false;\n\n    var openHeap = getHeap();\n    var closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n    graph.markDirty(start);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode);\n        var beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function(pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function(pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\n    }\n  },\n  cleanNode: function(node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  }\n};\n\n/**\n * A graph memory structure\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options]\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n */\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\n\nGraph.prototype.init = function() {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function() {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function(node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function(node) {\n  var ret = [];\n  var x = node.x;\n  var y = node.y;\n  var grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function() {\n  var graphString = [];\n  var nodes = this.grid;\n  for (var x = 0; x < nodes.length; x++) {\n    var rowDebug = [];\n    var row = nodes[x];\n    for (var y = 0; y < row.length; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function() {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function(fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function() {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function(node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function() {\n    return this.content.length;\n  },\n  rescoreElement: function(node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function(n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1;\n      var parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      }\n      // Found a parent that is less, no need to sink any further.\n      else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null;\n      var child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n};\n\nreturn {\n  astar: astar,\n  Graph: Graph\n};\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9qYXZhc2NyaXB0LWFzdGFyL2FzdGFyLmpzPzEyOTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBMEI7QUFDaEM7QUFDQSxHQUFHLFVBQVUsSUFBMEM7QUFDdkQsSUFBSSxpQ0FBTyxFQUFFLG9DQUFFLFVBQVU7QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDMUIsR0FBRyxNQUFNLGdCQUlOO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksT0FBTztBQUNuQixZQUFZLEtBQUs7QUFDakI7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUEsb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2phdmFzY3JpcHQtYXN0YXIvYXN0YXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBqYXZhc2NyaXB0LWFzdGFyIDAuNC4yXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9iZ3JpbnMvamF2YXNjcmlwdC1hc3RhclxuLy8gRnJlZWx5IGRpc3RyaWJ1dGFibGUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuLy8gSW1wbGVtZW50cyB0aGUgYXN0YXIgc2VhcmNoIGFsZ29yaXRobSBpbiBqYXZhc2NyaXB0IHVzaW5nIGEgQmluYXJ5IEhlYXAuXG4vLyBJbmNsdWRlcyBCaW5hcnkgSGVhcCAod2l0aCBtb2RpZmljYXRpb25zKSBmcm9tIE1hcmlqbiBIYXZlcmJla2UuXG4vLyBodHRwOi8vZWxvcXVlbnRqYXZhc2NyaXB0Lm5ldC9hcHBlbmRpeDIuaHRtbFxuKGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcbiAgLyogZ2xvYmFsIG1vZHVsZSwgZGVmaW5lICovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBkZWZpbml0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB3aW5kb3cuYXN0YXIgPSBleHBvcnRzLmFzdGFyO1xuICAgIHdpbmRvdy5HcmFwaCA9IGV4cG9ydHMuR3JhcGg7XG4gIH1cbn0pKGZ1bmN0aW9uKCkge1xuXG5mdW5jdGlvbiBwYXRoVG8obm9kZSkge1xuICB2YXIgY3VyciA9IG5vZGU7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChjdXJyLnBhcmVudCkge1xuICAgIHBhdGgudW5zaGlmdChjdXJyKTtcbiAgICBjdXJyID0gY3Vyci5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGdldEhlYXAoKSB7XG4gIHJldHVybiBuZXcgQmluYXJ5SGVhcChmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZjtcbiAgfSk7XG59XG5cbnZhciBhc3RhciA9IHtcbiAgLyoqXG4gICogUGVyZm9ybSBhbiBBKiBTZWFyY2ggb24gYSBncmFwaCBnaXZlbiBhIHN0YXJ0IGFuZCBlbmQgbm9kZS5cbiAgKiBAcGFyYW0ge0dyYXBofSBncmFwaFxuICAqIEBwYXJhbSB7R3JpZE5vZGV9IHN0YXJ0XG4gICogQHBhcmFtIHtHcmlkTm9kZX0gZW5kXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAqIEBwYXJhbSB7Ym9vbH0gW29wdGlvbnMuY2xvc2VzdF0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgICAgICAgICAgIHBhdGggdG8gdGhlIGNsb3Nlc3Qgbm9kZSBpZiB0aGUgdGFyZ2V0IGlzIHVucmVhY2hhYmxlLlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhldXJpc3RpY10gSGV1cmlzdGljIGZ1bmN0aW9uIChzZWVcbiAgKiAgICAgICAgICBhc3Rhci5oZXVyaXN0aWNzKS5cbiAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbihncmFwaCwgc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICAgIGdyYXBoLmNsZWFuRGlydHkoKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgaGV1cmlzdGljID0gb3B0aW9ucy5oZXVyaXN0aWMgfHwgYXN0YXIuaGV1cmlzdGljcy5tYW5oYXR0YW47XG4gICAgdmFyIGNsb3Nlc3QgPSBvcHRpb25zLmNsb3Nlc3QgfHwgZmFsc2U7XG5cbiAgICB2YXIgb3BlbkhlYXAgPSBnZXRIZWFwKCk7XG4gICAgdmFyIGNsb3Nlc3ROb2RlID0gc3RhcnQ7IC8vIHNldCB0aGUgc3RhcnQgbm9kZSB0byBiZSB0aGUgY2xvc2VzdCBpZiByZXF1aXJlZFxuXG4gICAgc3RhcnQuaCA9IGhldXJpc3RpYyhzdGFydCwgZW5kKTtcbiAgICBncmFwaC5tYXJrRGlydHkoc3RhcnQpO1xuXG4gICAgb3BlbkhlYXAucHVzaChzdGFydCk7XG5cbiAgICB3aGlsZSAob3BlbkhlYXAuc2l6ZSgpID4gMCkge1xuXG4gICAgICAvLyBHcmFiIHRoZSBsb3dlc3QgZih4KSB0byBwcm9jZXNzIG5leHQuICBIZWFwIGtlZXBzIHRoaXMgc29ydGVkIGZvciB1cy5cbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IG9wZW5IZWFwLnBvcCgpO1xuXG4gICAgICAvLyBFbmQgY2FzZSAtLSByZXN1bHQgaGFzIGJlZW4gZm91bmQsIHJldHVybiB0aGUgdHJhY2VkIHBhdGguXG4gICAgICBpZiAoY3VycmVudE5vZGUgPT09IGVuZCkge1xuICAgICAgICByZXR1cm4gcGF0aFRvKGN1cnJlbnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsIGNhc2UgLS0gbW92ZSBjdXJyZW50Tm9kZSBmcm9tIG9wZW4gdG8gY2xvc2VkLCBwcm9jZXNzIGVhY2ggb2YgaXRzIG5laWdoYm9ycy5cbiAgICAgIGN1cnJlbnROb2RlLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgIC8vIEZpbmQgYWxsIG5laWdoYm9ycyBmb3IgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5uZWlnaGJvcnMoY3VycmVudE5vZGUpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG5cbiAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCB8fCBuZWlnaGJvci5pc1dhbGwoKSkge1xuICAgICAgICAgIC8vIE5vdCBhIHZhbGlkIG5vZGUgdG8gcHJvY2Vzcywgc2tpcCB0byBuZXh0IG5laWdoYm9yLlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGcgc2NvcmUgaXMgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIGZyb20gc3RhcnQgdG8gY3VycmVudCBub2RlLlxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBwYXRoIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGlzIG5laWdoYm9yIGlzIHRoZSBzaG9ydGVzdCBvbmUgd2UgaGF2ZSBzZWVuIHlldC5cbiAgICAgICAgdmFyIGdTY29yZSA9IGN1cnJlbnROb2RlLmcgKyBuZWlnaGJvci5nZXRDb3N0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgdmFyIGJlZW5WaXNpdGVkID0gbmVpZ2hib3IudmlzaXRlZDtcblxuICAgICAgICBpZiAoIWJlZW5WaXNpdGVkIHx8IGdTY29yZSA8IG5laWdoYm9yLmcpIHtcblxuICAgICAgICAgIC8vIEZvdW5kIGFuIG9wdGltYWwgKHNvIGZhcikgcGF0aCB0byB0aGlzIG5vZGUuICBUYWtlIHNjb3JlIGZvciBub2RlIHRvIHNlZSBob3cgZ29vZCBpdCBpcy5cbiAgICAgICAgICBuZWlnaGJvci52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICBuZWlnaGJvci5oID0gbmVpZ2hib3IuaCB8fCBoZXVyaXN0aWMobmVpZ2hib3IsIGVuZCk7XG4gICAgICAgICAgbmVpZ2hib3IuZyA9IGdTY29yZTtcbiAgICAgICAgICBuZWlnaGJvci5mID0gbmVpZ2hib3IuZyArIG5laWdoYm9yLmg7XG4gICAgICAgICAgZ3JhcGgubWFya0RpcnR5KG5laWdoYm9yKTtcbiAgICAgICAgICBpZiAoY2xvc2VzdCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5laWdoYm91ciBpcyBjbG9zZXIgdGhhbiB0aGUgY3VycmVudCBjbG9zZXN0Tm9kZSBvciBpZiBpdCdzIGVxdWFsbHkgY2xvc2UgYnV0IGhhc1xuICAgICAgICAgICAgLy8gYSBjaGVhcGVyIHBhdGggdGhhbiB0aGUgY3VycmVudCBjbG9zZXN0IG5vZGUgdGhlbiBpdCBiZWNvbWVzIHRoZSBjbG9zZXN0IG5vZGVcbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5oIDwgY2xvc2VzdE5vZGUuaCB8fCAobmVpZ2hib3IuaCA9PT0gY2xvc2VzdE5vZGUuaCAmJiBuZWlnaGJvci5nIDwgY2xvc2VzdE5vZGUuZykpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdE5vZGUgPSBuZWlnaGJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWJlZW5WaXNpdGVkKSB7XG4gICAgICAgICAgICAvLyBQdXNoaW5nIHRvIGhlYXAgd2lsbCBwdXQgaXQgaW4gcHJvcGVyIHBsYWNlIGJhc2VkIG9uIHRoZSAnZicgdmFsdWUuXG4gICAgICAgICAgICBvcGVuSGVhcC5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBzZWVuIHRoZSBub2RlLCBidXQgc2luY2UgaXQgaGFzIGJlZW4gcmVzY29yZWQgd2UgbmVlZCB0byByZW9yZGVyIGl0IGluIHRoZSBoZWFwXG4gICAgICAgICAgICBvcGVuSGVhcC5yZXNjb3JlRWxlbWVudChuZWlnaGJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgIHJldHVybiBwYXRoVG8oY2xvc2VzdE5vZGUpO1xuICAgIH1cblxuICAgIC8vIE5vIHJlc3VsdCB3YXMgZm91bmQgLSBlbXB0eSBhcnJheSBzaWduaWZpZXMgZmFpbHVyZSB0byBmaW5kIHBhdGguXG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICAvLyBTZWUgbGlzdCBvZiBoZXVyaXN0aWNzOiBodHRwOi8vdGhlb3J5LnN0YW5mb3JkLmVkdS9+YW1pdHAvR2FtZVByb2dyYW1taW5nL0hldXJpc3RpY3MuaHRtbFxuICBoZXVyaXN0aWNzOiB7XG4gICAgbWFuaGF0dGFuOiBmdW5jdGlvbihwb3MwLCBwb3MxKSB7XG4gICAgICB2YXIgZDEgPSBNYXRoLmFicyhwb3MxLnggLSBwb3MwLngpO1xuICAgICAgdmFyIGQyID0gTWF0aC5hYnMocG9zMS55IC0gcG9zMC55KTtcbiAgICAgIHJldHVybiBkMSArIGQyO1xuICAgIH0sXG4gICAgZGlhZ29uYWw6IGZ1bmN0aW9uKHBvczAsIHBvczEpIHtcbiAgICAgIHZhciBEID0gMTtcbiAgICAgIHZhciBEMiA9IE1hdGguc3FydCgyKTtcbiAgICAgIHZhciBkMSA9IE1hdGguYWJzKHBvczEueCAtIHBvczAueCk7XG4gICAgICB2YXIgZDIgPSBNYXRoLmFicyhwb3MxLnkgLSBwb3MwLnkpO1xuICAgICAgcmV0dXJuIChEICogKGQxICsgZDIpKSArICgoRDIgLSAoMiAqIEQpKSAqIE1hdGgubWluKGQxLCBkMikpO1xuICAgIH1cbiAgfSxcbiAgY2xlYW5Ob2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS5mID0gMDtcbiAgICBub2RlLmcgPSAwO1xuICAgIG5vZGUuaCA9IDA7XG4gICAgbm9kZS52aXNpdGVkID0gZmFsc2U7XG4gICAgbm9kZS5jbG9zZWQgPSBmYWxzZTtcbiAgICBub2RlLnBhcmVudCA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQSBncmFwaCBtZW1vcnkgc3RydWN0dXJlXG4gKiBAcGFyYW0ge0FycmF5fSBncmlkSW4gMkQgYXJyYXkgb2YgaW5wdXQgd2VpZ2h0c1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sfSBbb3B0aW9ucy5kaWFnb25hbF0gU3BlY2lmaWVzIHdoZXRoZXIgZGlhZ29uYWwgbW92ZXMgYXJlIGFsbG93ZWRcbiAqL1xuZnVuY3Rpb24gR3JhcGgoZ3JpZEluLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5vZGVzID0gW107XG4gIHRoaXMuZGlhZ29uYWwgPSAhIW9wdGlvbnMuZGlhZ29uYWw7XG4gIHRoaXMuZ3JpZCA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGdyaWRJbi5sZW5ndGg7IHgrKykge1xuICAgIHRoaXMuZ3JpZFt4XSA9IFtdO1xuXG4gICAgZm9yICh2YXIgeSA9IDAsIHJvdyA9IGdyaWRJblt4XTsgeSA8IHJvdy5sZW5ndGg7IHkrKykge1xuICAgICAgdmFyIG5vZGUgPSBuZXcgR3JpZE5vZGUoeCwgeSwgcm93W3ldKTtcbiAgICAgIHRoaXMuZ3JpZFt4XVt5XSA9IG5vZGU7XG4gICAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHRoaXMuaW5pdCgpO1xufVxuXG5HcmFwaC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRpcnR5Tm9kZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXN0YXIuY2xlYW5Ob2RlKHRoaXMubm9kZXNbaV0pO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuY2xlYW5EaXJ0eSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlydHlOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGFzdGFyLmNsZWFuTm9kZSh0aGlzLmRpcnR5Tm9kZXNbaV0pO1xuICB9XG4gIHRoaXMuZGlydHlOb2RlcyA9IFtdO1xufTtcblxuR3JhcGgucHJvdG90eXBlLm1hcmtEaXJ0eSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5kaXJ0eU5vZGVzLnB1c2gobm9kZSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgcmV0ID0gW107XG4gIHZhciB4ID0gbm9kZS54O1xuICB2YXIgeSA9IG5vZGUueTtcbiAgdmFyIGdyaWQgPSB0aGlzLmdyaWQ7XG5cbiAgLy8gV2VzdFxuICBpZiAoZ3JpZFt4IC0gMV0gJiYgZ3JpZFt4IC0gMV1beV0pIHtcbiAgICByZXQucHVzaChncmlkW3ggLSAxXVt5XSk7XG4gIH1cblxuICAvLyBFYXN0XG4gIGlmIChncmlkW3ggKyAxXSAmJiBncmlkW3ggKyAxXVt5XSkge1xuICAgIHJldC5wdXNoKGdyaWRbeCArIDFdW3ldKTtcbiAgfVxuXG4gIC8vIFNvdXRoXG4gIGlmIChncmlkW3hdICYmIGdyaWRbeF1beSAtIDFdKSB7XG4gICAgcmV0LnB1c2goZ3JpZFt4XVt5IC0gMV0pO1xuICB9XG5cbiAgLy8gTm9ydGhcbiAgaWYgKGdyaWRbeF0gJiYgZ3JpZFt4XVt5ICsgMV0pIHtcbiAgICByZXQucHVzaChncmlkW3hdW3kgKyAxXSk7XG4gIH1cblxuICBpZiAodGhpcy5kaWFnb25hbCkge1xuICAgIC8vIFNvdXRod2VzdFxuICAgIGlmIChncmlkW3ggLSAxXSAmJiBncmlkW3ggLSAxXVt5IC0gMV0pIHtcbiAgICAgIHJldC5wdXNoKGdyaWRbeCAtIDFdW3kgLSAxXSk7XG4gICAgfVxuXG4gICAgLy8gU291dGhlYXN0XG4gICAgaWYgKGdyaWRbeCArIDFdICYmIGdyaWRbeCArIDFdW3kgLSAxXSkge1xuICAgICAgcmV0LnB1c2goZ3JpZFt4ICsgMV1beSAtIDFdKTtcbiAgICB9XG5cbiAgICAvLyBOb3J0aHdlc3RcbiAgICBpZiAoZ3JpZFt4IC0gMV0gJiYgZ3JpZFt4IC0gMV1beSArIDFdKSB7XG4gICAgICByZXQucHVzaChncmlkW3ggLSAxXVt5ICsgMV0pO1xuICAgIH1cblxuICAgIC8vIE5vcnRoZWFzdFxuICAgIGlmIChncmlkW3ggKyAxXSAmJiBncmlkW3ggKyAxXVt5ICsgMV0pIHtcbiAgICAgIHJldC5wdXNoKGdyaWRbeCArIDFdW3kgKyAxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZ3JhcGhTdHJpbmcgPSBbXTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ncmlkO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IG5vZGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIHJvd0RlYnVnID0gW107XG4gICAgdmFyIHJvdyA9IG5vZGVzW3hdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcm93Lmxlbmd0aDsgeSsrKSB7XG4gICAgICByb3dEZWJ1Zy5wdXNoKHJvd1t5XS53ZWlnaHQpO1xuICAgIH1cbiAgICBncmFwaFN0cmluZy5wdXNoKHJvd0RlYnVnLmpvaW4oXCIgXCIpKTtcbiAgfVxuICByZXR1cm4gZ3JhcGhTdHJpbmcuam9pbihcIlxcblwiKTtcbn07XG5cbmZ1bmN0aW9uIEdyaWROb2RlKHgsIHksIHdlaWdodCkge1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLndlaWdodCA9IHdlaWdodDtcbn1cblxuR3JpZE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcIltcIiArIHRoaXMueCArIFwiIFwiICsgdGhpcy55ICsgXCJdXCI7XG59O1xuXG5HcmlkTm9kZS5wcm90b3R5cGUuZ2V0Q29zdCA9IGZ1bmN0aW9uKGZyb21OZWlnaGJvcikge1xuICAvLyBUYWtlIGRpYWdvbmFsIHdlaWdodCBpbnRvIGNvbnNpZGVyYXRpb24uXG4gIGlmIChmcm9tTmVpZ2hib3IgJiYgZnJvbU5laWdoYm9yLnggIT0gdGhpcy54ICYmIGZyb21OZWlnaGJvci55ICE9IHRoaXMueSkge1xuICAgIHJldHVybiB0aGlzLndlaWdodCAqIDEuNDE0MjE7XG4gIH1cbiAgcmV0dXJuIHRoaXMud2VpZ2h0O1xufTtcblxuR3JpZE5vZGUucHJvdG90eXBlLmlzV2FsbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53ZWlnaHQgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBCaW5hcnlIZWFwKHNjb3JlRnVuY3Rpb24pIHtcbiAgdGhpcy5jb250ZW50ID0gW107XG4gIHRoaXMuc2NvcmVGdW5jdGlvbiA9IHNjb3JlRnVuY3Rpb247XG59XG5cbkJpbmFyeUhlYXAucHJvdG90eXBlID0ge1xuICBwdXNoOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgLy8gQWRkIHRoZSBuZXcgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICB0aGlzLmNvbnRlbnQucHVzaChlbGVtZW50KTtcblxuICAgIC8vIEFsbG93IGl0IHRvIHNpbmsgZG93bi5cbiAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcbiAgfSxcbiAgcG9wOiBmdW5jdGlvbigpIHtcbiAgICAvLyBTdG9yZSB0aGUgZmlyc3QgZWxlbWVudCBzbyB3ZSBjYW4gcmV0dXJuIGl0IGxhdGVyLlxuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XG4gICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxuICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IGJ1YmJsZSB1cC5cbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29udGVudFswXSA9IGVuZDtcbiAgICAgIHRoaXMuYnViYmxlVXAoMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBpID0gdGhpcy5jb250ZW50LmluZGV4T2Yobm9kZSk7XG5cbiAgICAvLyBXaGVuIGl0IGlzIGZvdW5kLCB0aGUgcHJvY2VzcyBzZWVuIGluICdwb3AnIGlzIHJlcGVhdGVkXG4gICAgLy8gdG8gZmlsbCB1cCB0aGUgaG9sZS5cbiAgICB2YXIgZW5kID0gdGhpcy5jb250ZW50LnBvcCgpO1xuXG4gICAgaWYgKGkgIT09IHRoaXMuY29udGVudC5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmNvbnRlbnRbaV0gPSBlbmQ7XG5cbiAgICAgIGlmICh0aGlzLnNjb3JlRnVuY3Rpb24oZW5kKSA8IHRoaXMuc2NvcmVGdW5jdGlvbihub2RlKSkge1xuICAgICAgICB0aGlzLnNpbmtEb3duKGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5idWJibGVVcChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICB9LFxuICByZXNjb3JlRWxlbWVudDogZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMuc2lua0Rvd24odGhpcy5jb250ZW50LmluZGV4T2Yobm9kZSkpO1xuICB9LFxuICBzaW5rRG93bjogZnVuY3Rpb24obikge1xuICAgIC8vIEZldGNoIHRoZSBlbGVtZW50IHRoYXQgaGFzIHRvIGJlIHN1bmsuXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNvbnRlbnRbbl07XG5cbiAgICAvLyBXaGVuIGF0IDAsIGFuIGVsZW1lbnQgY2FuIG5vdCBzaW5rIGFueSBmdXJ0aGVyLlxuICAgIHdoaWxlIChuID4gMCkge1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwYXJlbnQgZWxlbWVudCdzIGluZGV4LCBhbmQgZmV0Y2ggaXQuXG4gICAgICB2YXIgcGFyZW50TiA9ICgobiArIDEpID4+IDEpIC0gMTtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmNvbnRlbnRbcGFyZW50Tl07XG4gICAgICAvLyBTd2FwIHRoZSBlbGVtZW50cyBpZiB0aGUgcGFyZW50IGlzIGdyZWF0ZXIuXG4gICAgICBpZiAodGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpIDwgdGhpcy5zY29yZUZ1bmN0aW9uKHBhcmVudCkpIHtcbiAgICAgICAgdGhpcy5jb250ZW50W3BhcmVudE5dID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5jb250ZW50W25dID0gcGFyZW50O1xuICAgICAgICAvLyBVcGRhdGUgJ24nIHRvIGNvbnRpbnVlIGF0IHRoZSBuZXcgcG9zaXRpb24uXG4gICAgICAgIG4gPSBwYXJlbnROO1xuICAgICAgfVxuICAgICAgLy8gRm91bmQgYSBwYXJlbnQgdGhhdCBpcyBsZXNzLCBubyBuZWVkIHRvIHNpbmsgYW55IGZ1cnRoZXIuXG4gICAgICBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBidWJibGVVcDogZnVuY3Rpb24obikge1xuICAgIC8vIExvb2sgdXAgdGhlIHRhcmdldCBlbGVtZW50IGFuZCBpdHMgc2NvcmUuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNvbnRlbnRbbl07XG4gICAgdmFyIGVsZW1TY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBDb21wdXRlIHRoZSBpbmRpY2VzIG9mIHRoZSBjaGlsZCBlbGVtZW50cy5cbiAgICAgIHZhciBjaGlsZDJOID0gKG4gKyAxKSA8PCAxO1xuICAgICAgdmFyIGNoaWxkMU4gPSBjaGlsZDJOIC0gMTtcbiAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LCBpZiBhbnkuXG4gICAgICB2YXIgc3dhcCA9IG51bGw7XG4gICAgICB2YXIgY2hpbGQxU2NvcmU7XG4gICAgICAvLyBJZiB0aGUgZmlyc3QgY2hpbGQgZXhpc3RzIChpcyBpbnNpZGUgdGhlIGFycmF5KS4uLlxuICAgICAgaWYgKGNoaWxkMU4gPCBsZW5ndGgpIHtcbiAgICAgICAgLy8gTG9vayBpdCB1cCBhbmQgY29tcHV0ZSBpdHMgc2NvcmUuXG4gICAgICAgIHZhciBjaGlsZDEgPSB0aGlzLmNvbnRlbnRbY2hpbGQxTl07XG4gICAgICAgIGNoaWxkMVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHNjb3JlIGlzIGxlc3MgdGhhbiBvdXIgZWxlbWVudCdzLCB3ZSBuZWVkIHRvIHN3YXAuXG4gICAgICAgIGlmIChjaGlsZDFTY29yZSA8IGVsZW1TY29yZSkge1xuICAgICAgICAgIHN3YXAgPSBjaGlsZDFOO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERvIHRoZSBzYW1lIGNoZWNrcyBmb3IgdGhlIG90aGVyIGNoaWxkLlxuICAgICAgaWYgKGNoaWxkMk4gPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoaWxkMiA9IHRoaXMuY29udGVudFtjaGlsZDJOXTtcbiAgICAgICAgdmFyIGNoaWxkMlNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGNoaWxkMik7XG4gICAgICAgIGlmIChjaGlsZDJTY29yZSA8IChzd2FwID09PSBudWxsID8gZWxlbVNjb3JlIDogY2hpbGQxU2NvcmUpKSB7XG4gICAgICAgICAgc3dhcCA9IGNoaWxkMk47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgbmVlZHMgdG8gYmUgbW92ZWQsIHN3YXAgaXQsIGFuZCBjb250aW51ZS5cbiAgICAgIGlmIChzd2FwICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29udGVudFtuXSA9IHRoaXMuY29udGVudFtzd2FwXTtcbiAgICAgICAgdGhpcy5jb250ZW50W3N3YXBdID0gZWxlbWVudDtcbiAgICAgICAgbiA9IHN3YXA7XG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UsIHdlIGFyZSBkb25lLlxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxucmV0dXJuIHtcbiAgYXN0YXI6IGFzdGFyLFxuICBHcmFwaDogR3JhcGhcbn07XG5cbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/javascript-astar/astar.js\n");

/***/ }),

/***/ "./channel.ts":
/*!********************!*\
  !*** ./channel.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Channel)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./utils.ts\");\n// Mostly sourced from PatrolJS at the moment. TODO: come back and reimplement this as an incomplete\r\n// funnel algorithm so astar checks can be more accurate.\r\n\r\n/**\r\n * @private\r\n */\r\nclass Channel {\r\n    constructor() {\r\n        this.portals = [];\r\n        this.path = [];\r\n    }\r\n    push(p1, p2) {\r\n        if (p2 === undefined)\r\n            p2 = p1;\r\n        this.portals.push({\r\n            left: p1,\r\n            right: p2,\r\n        });\r\n    }\r\n    stringPull() {\r\n        const portals = this.portals;\r\n        const pts = [];\r\n        // Init scan state\r\n        let apexIndex = 0;\r\n        let leftIndex = 0;\r\n        let rightIndex = 0;\r\n        let portalApex = portals[0].left;\r\n        let portalLeft = portals[0].left;\r\n        let portalRight = portals[0].right;\r\n        // Add start point.\r\n        pts.push(portalApex);\r\n        for (var i = 1; i < portals.length; i++) {\r\n            // Find the next portal vertices\r\n            const left = portals[i].left;\r\n            const right = portals[i].right;\r\n            // Update right vertex.\r\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.triarea2)(portalApex, portalRight, right) <= 0.0) {\r\n                if (portalApex.equals(portalRight) || (0,_utils__WEBPACK_IMPORTED_MODULE_0__.triarea2)(portalApex, portalLeft, right) > 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalRight = right;\r\n                    rightIndex = i;\r\n                }\r\n                else {\r\n                    // Right vertex just crossed over the left vertex, so the left vertex should\r\n                    // now be part of the path.\r\n                    pts.push(portalLeft);\r\n                    // Restart scan from portal left point.\r\n                    // Make current left the new apex.\r\n                    portalApex = portalLeft;\r\n                    apexIndex = leftIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n            // Update left vertex.\r\n            if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.triarea2)(portalApex, portalLeft, left) >= 0.0) {\r\n                if (portalApex.equals(portalLeft) || (0,_utils__WEBPACK_IMPORTED_MODULE_0__.triarea2)(portalApex, portalRight, left) < 0.0) {\r\n                    // Tighten the funnel.\r\n                    portalLeft = left;\r\n                    leftIndex = i;\r\n                }\r\n                else {\r\n                    // Left vertex just crossed over the right vertex, so the right vertex should\r\n                    // now be part of the path\r\n                    pts.push(portalRight);\r\n                    // Restart scan from portal right point.\r\n                    // Make current right the new apex.\r\n                    portalApex = portalRight;\r\n                    apexIndex = rightIndex;\r\n                    // Reset portal\r\n                    portalLeft = portalApex;\r\n                    portalRight = portalApex;\r\n                    leftIndex = apexIndex;\r\n                    rightIndex = apexIndex;\r\n                    // Restart scan\r\n                    i = apexIndex;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        if (pts.length === 0 || !pts[pts.length - 1].equals(portals[portals.length - 1].left)) {\r\n            // Append last point to path.\r\n            pts.push(portals[portals.length - 1].left);\r\n        }\r\n        this.path = pts;\r\n        return pts;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vY2hhbm5lbC50cz9jMGJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNtQztBQUNuQztBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBUTtBQUN4QixzREFBc0QsZ0RBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBUTtBQUN4QixxREFBcUQsZ0RBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9jaGFubmVsLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTW9zdGx5IHNvdXJjZWQgZnJvbSBQYXRyb2xKUyBhdCB0aGUgbW9tZW50LiBUT0RPOiBjb21lIGJhY2sgYW5kIHJlaW1wbGVtZW50IHRoaXMgYXMgYW4gaW5jb21wbGV0ZVxyXG4vLyBmdW5uZWwgYWxnb3JpdGhtIHNvIGFzdGFyIGNoZWNrcyBjYW4gYmUgbW9yZSBhY2N1cmF0ZS5cclxuaW1wb3J0IHsgdHJpYXJlYTIgfSBmcm9tIFwiLi91dGlsc1wiO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYW5uZWwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5wb3J0YWxzID0gW107XHJcbiAgICAgICAgdGhpcy5wYXRoID0gW107XHJcbiAgICB9XHJcbiAgICBwdXNoKHAxLCBwMikge1xyXG4gICAgICAgIGlmIChwMiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBwMiA9IHAxO1xyXG4gICAgICAgIHRoaXMucG9ydGFscy5wdXNoKHtcclxuICAgICAgICAgICAgbGVmdDogcDEsXHJcbiAgICAgICAgICAgIHJpZ2h0OiBwMixcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0cmluZ1B1bGwoKSB7XHJcbiAgICAgICAgY29uc3QgcG9ydGFscyA9IHRoaXMucG9ydGFscztcclxuICAgICAgICBjb25zdCBwdHMgPSBbXTtcclxuICAgICAgICAvLyBJbml0IHNjYW4gc3RhdGVcclxuICAgICAgICBsZXQgYXBleEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgbGVmdEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgcmlnaHRJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IHBvcnRhbEFwZXggPSBwb3J0YWxzWzBdLmxlZnQ7XHJcbiAgICAgICAgbGV0IHBvcnRhbExlZnQgPSBwb3J0YWxzWzBdLmxlZnQ7XHJcbiAgICAgICAgbGV0IHBvcnRhbFJpZ2h0ID0gcG9ydGFsc1swXS5yaWdodDtcclxuICAgICAgICAvLyBBZGQgc3RhcnQgcG9pbnQuXHJcbiAgICAgICAgcHRzLnB1c2gocG9ydGFsQXBleCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb3J0YWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgcG9ydGFsIHZlcnRpY2VzXHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBwb3J0YWxzW2ldLmxlZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcG9ydGFsc1tpXS5yaWdodDtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHJpZ2h0IHZlcnRleC5cclxuICAgICAgICAgICAgaWYgKHRyaWFyZWEyKHBvcnRhbEFwZXgsIHBvcnRhbFJpZ2h0LCByaWdodCkgPD0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9ydGFsQXBleC5lcXVhbHMocG9ydGFsUmlnaHQpIHx8IHRyaWFyZWEyKHBvcnRhbEFwZXgsIHBvcnRhbExlZnQsIHJpZ2h0KSA+IDAuMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRpZ2h0ZW4gdGhlIGZ1bm5lbC5cclxuICAgICAgICAgICAgICAgICAgICBwb3J0YWxSaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgdmVydGV4IGp1c3QgY3Jvc3NlZCBvdmVyIHRoZSBsZWZ0IHZlcnRleCwgc28gdGhlIGxlZnQgdmVydGV4IHNob3VsZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyBiZSBwYXJ0IG9mIHRoZSBwYXRoLlxyXG4gICAgICAgICAgICAgICAgICAgIHB0cy5wdXNoKHBvcnRhbExlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RhcnQgc2NhbiBmcm9tIHBvcnRhbCBsZWZ0IHBvaW50LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgY3VycmVudCBsZWZ0IHRoZSBuZXcgYXBleC5cclxuICAgICAgICAgICAgICAgICAgICBwb3J0YWxBcGV4ID0gcG9ydGFsTGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBhcGV4SW5kZXggPSBsZWZ0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgcG9ydGFsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9ydGFsTGVmdCA9IHBvcnRhbEFwZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9ydGFsUmlnaHQgPSBwb3J0YWxBcGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRJbmRleCA9IGFwZXhJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICByaWdodEluZGV4ID0gYXBleEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RhcnQgc2NhblxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBhcGV4SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGxlZnQgdmVydGV4LlxyXG4gICAgICAgICAgICBpZiAodHJpYXJlYTIocG9ydGFsQXBleCwgcG9ydGFsTGVmdCwgbGVmdCkgPj0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9ydGFsQXBleC5lcXVhbHMocG9ydGFsTGVmdCkgfHwgdHJpYXJlYTIocG9ydGFsQXBleCwgcG9ydGFsUmlnaHQsIGxlZnQpIDwgMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGlnaHRlbiB0aGUgZnVubmVsLlxyXG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbExlZnQgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0IHZlcnRleCBqdXN0IGNyb3NzZWQgb3ZlciB0aGUgcmlnaHQgdmVydGV4LCBzbyB0aGUgcmlnaHQgdmVydGV4IHNob3VsZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyBiZSBwYXJ0IG9mIHRoZSBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgcHRzLnB1c2gocG9ydGFsUmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RhcnQgc2NhbiBmcm9tIHBvcnRhbCByaWdodCBwb2ludC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGN1cnJlbnQgcmlnaHQgdGhlIG5ldyBhcGV4LlxyXG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbEFwZXggPSBwb3J0YWxSaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBhcGV4SW5kZXggPSByaWdodEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHBvcnRhbFxyXG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbExlZnQgPSBwb3J0YWxBcGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbFJpZ2h0ID0gcG9ydGFsQXBleDtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0SW5kZXggPSBhcGV4SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRJbmRleCA9IGFwZXhJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0YXJ0IHNjYW5cclxuICAgICAgICAgICAgICAgICAgICBpID0gYXBleEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwdHMubGVuZ3RoID09PSAwIHx8ICFwdHNbcHRzLmxlbmd0aCAtIDFdLmVxdWFscyhwb3J0YWxzW3BvcnRhbHMubGVuZ3RoIC0gMV0ubGVmdCkpIHtcclxuICAgICAgICAgICAgLy8gQXBwZW5kIGxhc3QgcG9pbnQgdG8gcGF0aC5cclxuICAgICAgICAgICAgcHRzLnB1c2gocG9ydGFsc1twb3J0YWxzLmxlbmd0aCAtIDFdLmxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhdGggPSBwdHM7XHJcbiAgICAgICAgcmV0dXJuIHB0cztcclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./channel.ts\n");

/***/ }),

/***/ "./common-types.ts":
/*!*************************!*\
  !*** ./common-types.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vY29tbW9uLXR5cGVzLnRzP2Y2YTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFVIiwiZmlsZSI6Ii4vY29tbW9uLXR5cGVzLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./common-types.ts\n");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NavMesh\": () => (/* reexport safe */ _navmesh__WEBPACK_IMPORTED_MODULE_0__.default),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _navmesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./navmesh */ \"./navmesh.ts\");\n/* harmony import */ var _common_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common-types */ \"./common-types.ts\");\n/**\r\n * `navmesh` is the core logic package. It is game-engine agnostic, usable outside of Phaser.\r\n * @packageDocumentation\r\n * @module navmesh\r\n */\r\n\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_navmesh__WEBPACK_IMPORTED_MODULE_0__.default);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vaW5kZXgudHM/OWNmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnQztBQUNiO0FBQ1k7QUFDL0IsaUVBQWUsNkNBQU8sRUFBQyIsImZpbGUiOiIuL2luZGV4LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIGBuYXZtZXNoYCBpcyB0aGUgY29yZSBsb2dpYyBwYWNrYWdlLiBJdCBpcyBnYW1lLWVuZ2luZSBhZ25vc3RpYywgdXNhYmxlIG91dHNpZGUgb2YgUGhhc2VyLlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICogQG1vZHVsZSBuYXZtZXNoXHJcbiAqL1xyXG5pbXBvcnQgTmF2TWVzaCBmcm9tIFwiLi9uYXZtZXNoXCI7XHJcbmV4cG9ydCB7IE5hdk1lc2ggfTtcclxuZXhwb3J0ICogZnJvbSBcIi4vY29tbW9uLXR5cGVzXCI7XHJcbmV4cG9ydCBkZWZhdWx0IE5hdk1lc2g7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./index.ts\n");

/***/ }),

/***/ "./math/line.ts":
/*!**********************!*\
  !*** ./math/line.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Line)\n/* harmony export */ });\n/* harmony import */ var _vector_2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vector-2 */ \"./math/vector-2.ts\");\n\r\n/**\r\n * Stripped down version of Phaser's Line with just the functionality needed for navmeshes.\r\n *\r\n * @export\r\n * @class Line\r\n */\r\nclass Line {\r\n    constructor(x1, y1, x2, y2) {\r\n        this.start = new _vector_2__WEBPACK_IMPORTED_MODULE_0__.default(x1, y1);\r\n        this.end = new _vector_2__WEBPACK_IMPORTED_MODULE_0__.default(x2, y2);\r\n        this.left = Math.min(x1, x2);\r\n        this.right = Math.max(x1, x2);\r\n        this.top = Math.min(y1, y2);\r\n        this.bottom = Math.max(y1, y2);\r\n    }\r\n    pointOnSegment(x, y) {\r\n        return (x >= this.left &&\r\n            x <= this.right &&\r\n            y >= this.top &&\r\n            y <= this.bottom &&\r\n            this.pointOnLine(x, y));\r\n    }\r\n    pointOnLine(x, y) {\r\n        // Compare slope of line start -> xy to line start -> line end\r\n        return (x - this.left) * (this.bottom - this.top) === (this.right - this.left) * (y - this.top);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vbWF0aC9saW5lLnRzPzRkYTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBLHlCQUF5Qiw4Q0FBTztBQUNoQyx1QkFBdUIsOENBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL21hdGgvbGluZS50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWZWN0b3IyIGZyb20gXCIuL3ZlY3Rvci0yXCI7XHJcbi8qKlxyXG4gKiBTdHJpcHBlZCBkb3duIHZlcnNpb24gb2YgUGhhc2VyJ3MgTGluZSB3aXRoIGp1c3QgdGhlIGZ1bmN0aW9uYWxpdHkgbmVlZGVkIGZvciBuYXZtZXNoZXMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIExpbmVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmUge1xyXG4gICAgY29uc3RydWN0b3IoeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IFZlY3RvcjIoeDEsIHkxKTtcclxuICAgICAgICB0aGlzLmVuZCA9IG5ldyBWZWN0b3IyKHgyLCB5Mik7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gTWF0aC5taW4oeDEsIHgyKTtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyKTtcclxuICAgICAgICB0aGlzLnRvcCA9IE1hdGgubWluKHkxLCB5Mik7XHJcbiAgICAgICAgdGhpcy5ib3R0b20gPSBNYXRoLm1heCh5MSwgeTIpO1xyXG4gICAgfVxyXG4gICAgcG9pbnRPblNlZ21lbnQoeCwgeSkge1xyXG4gICAgICAgIHJldHVybiAoeCA+PSB0aGlzLmxlZnQgJiZcclxuICAgICAgICAgICAgeCA8PSB0aGlzLnJpZ2h0ICYmXHJcbiAgICAgICAgICAgIHkgPj0gdGhpcy50b3AgJiZcclxuICAgICAgICAgICAgeSA8PSB0aGlzLmJvdHRvbSAmJlxyXG4gICAgICAgICAgICB0aGlzLnBvaW50T25MaW5lKHgsIHkpKTtcclxuICAgIH1cclxuICAgIHBvaW50T25MaW5lKHgsIHkpIHtcclxuICAgICAgICAvLyBDb21wYXJlIHNsb3BlIG9mIGxpbmUgc3RhcnQgLT4geHkgdG8gbGluZSBzdGFydCAtPiBsaW5lIGVuZFxyXG4gICAgICAgIHJldHVybiAoeCAtIHRoaXMubGVmdCkgKiAodGhpcy5ib3R0b20gLSB0aGlzLnRvcCkgPT09ICh0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0KSAqICh5IC0gdGhpcy50b3ApO1xyXG4gICAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./math/line.ts\n");

/***/ }),

/***/ "./math/polygon.ts":
/*!*************************!*\
  !*** ./math/polygon.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Polygon)\n/* harmony export */ });\n/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line */ \"./math/line.ts\");\n\r\n/**\r\n * Stripped down version of Phaser's Polygon with just the functionality needed for navmeshes.\r\n *\r\n * @export\r\n * @class Polygon\r\n */\r\nclass Polygon {\r\n    constructor(points, closed = true) {\r\n        this.isClosed = closed;\r\n        this.points = points;\r\n        this.edges = [];\r\n        for (let i = 1; i < points.length; i++) {\r\n            const p1 = points[i - 1];\r\n            const p2 = points[i];\r\n            this.edges.push(new _line__WEBPACK_IMPORTED_MODULE_0__.default(p1.x, p1.y, p2.x, p2.y));\r\n        }\r\n        if (this.isClosed) {\r\n            const first = points[0];\r\n            const last = points[points.length - 1];\r\n            this.edges.push(new _line__WEBPACK_IMPORTED_MODULE_0__.default(first.x, first.y, last.x, last.y));\r\n        }\r\n    }\r\n    contains(x, y) {\r\n        let inside = false;\r\n        for (let i = -1, j = this.points.length - 1; ++i < this.points.length; j = i) {\r\n            const ix = this.points[i].x;\r\n            const iy = this.points[i].y;\r\n            const jx = this.points[j].x;\r\n            const jy = this.points[j].y;\r\n            if (((iy <= y && y < jy) || (jy <= y && y < iy)) &&\r\n                x < ((jx - ix) * (y - iy)) / (jy - iy) + ix) {\r\n                inside = !inside;\r\n            }\r\n        }\r\n        return inside;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vbWF0aC9wb2x5Z29uLnRzPzg2ZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBLGdDQUFnQywwQ0FBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQkFBMEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbWF0aC9wb2x5Z29uLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExpbmUgZnJvbSBcIi4vbGluZVwiO1xyXG4vKipcclxuICogU3RyaXBwZWQgZG93biB2ZXJzaW9uIG9mIFBoYXNlcidzIFBvbHlnb24gd2l0aCBqdXN0IHRoZSBmdW5jdGlvbmFsaXR5IG5lZWRlZCBmb3IgbmF2bWVzaGVzLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBjbGFzcyBQb2x5Z29uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uIHtcclxuICAgIGNvbnN0cnVjdG9yKHBvaW50cywgY2xvc2VkID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBjbG9zZWQ7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgdGhpcy5lZGdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAxID0gcG9pbnRzW2kgLSAxXTtcclxuICAgICAgICAgICAgY29uc3QgcDIgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgIHRoaXMuZWRnZXMucHVzaChuZXcgTGluZShwMS54LCBwMS55LCBwMi54LCBwMi55KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gcG9pbnRzWzBdO1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgdGhpcy5lZGdlcy5wdXNoKG5ldyBMaW5lKGZpcnN0LngsIGZpcnN0LnksIGxhc3QueCwgbGFzdC55KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29udGFpbnMoeCwgeSkge1xyXG4gICAgICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gLTEsIGogPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxOyArK2kgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGogPSBpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl4ID0gdGhpcy5wb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgY29uc3QgaXkgPSB0aGlzLnBvaW50c1tpXS55O1xyXG4gICAgICAgICAgICBjb25zdCBqeCA9IHRoaXMucG9pbnRzW2pdLng7XHJcbiAgICAgICAgICAgIGNvbnN0IGp5ID0gdGhpcy5wb2ludHNbal0ueTtcclxuICAgICAgICAgICAgaWYgKCgoaXkgPD0geSAmJiB5IDwgankpIHx8IChqeSA8PSB5ICYmIHkgPCBpeSkpICYmXHJcbiAgICAgICAgICAgICAgICB4IDwgKChqeCAtIGl4KSAqICh5IC0gaXkpKSAvIChqeSAtIGl5KSArIGl4KSB7XHJcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnNpZGU7XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./math/polygon.ts\n");

/***/ }),

/***/ "./math/vector-2.ts":
/*!**************************!*\
  !*** ./math/vector-2.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Vector2)\n/* harmony export */ });\n/**\r\n * Stripped down version of Phaser's Vector2 with just the functionality needed for navmeshes.\r\n *\r\n * @export\r\n * @class Vector2\r\n */\r\nclass Vector2 {\r\n    constructor(x = 0, y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    equals(v) {\r\n        return this.x === v.x && this.y === v.y;\r\n    }\r\n    angle(v) {\r\n        return Math.atan2(v.y - this.y, v.x - this.x);\r\n    }\r\n    distance(v) {\r\n        const dx = v.x - this.x;\r\n        const dy = v.y - this.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n    }\r\n    subtract(v) {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n    }\r\n    clone() {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vbWF0aC92ZWN0b3ItMi50cz82MGQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL21hdGgvdmVjdG9yLTIudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU3RyaXBwZWQgZG93biB2ZXJzaW9uIG9mIFBoYXNlcidzIFZlY3RvcjIgd2l0aCBqdXN0IHRoZSBmdW5jdGlvbmFsaXR5IG5lZWRlZCBmb3IgbmF2bWVzaGVzLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBjbGFzcyBWZWN0b3IyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3IyIHtcclxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCkge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgIH1cclxuICAgIGVxdWFscyh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gdi54ICYmIHRoaXMueSA9PT0gdi55O1xyXG4gICAgfVxyXG4gICAgYW5nbGUodikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHYueSAtIHRoaXMueSwgdi54IC0gdGhpcy54KTtcclxuICAgIH1cclxuICAgIGRpc3RhbmNlKHYpIHtcclxuICAgICAgICBjb25zdCBkeCA9IHYueCAtIHRoaXMueDtcclxuICAgICAgICBjb25zdCBkeSA9IHYueSAtIHRoaXMueTtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgIH1cclxuICAgIGFkZCh2KSB7XHJcbiAgICAgICAgdGhpcy54ICs9IHYueDtcclxuICAgICAgICB0aGlzLnkgKz0gdi55O1xyXG4gICAgfVxyXG4gICAgc3VidHJhY3Qodikge1xyXG4gICAgICAgIHRoaXMueCAtPSB2Lng7XHJcbiAgICAgICAgdGhpcy55IC09IHYueTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./math/vector-2.ts\n");

/***/ }),

/***/ "./navgraph.ts":
/*!*********************!*\
  !*** ./navgraph.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var javascript_astar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! javascript-astar */ \"../../../node_modules/javascript-astar/astar.js\");\n/* harmony import */ var javascript_astar__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(javascript_astar__WEBPACK_IMPORTED_MODULE_0__);\n\r\n/**\r\n * Graph for javascript-astar. It implements the functionality for astar. See GPS test from astar\r\n * repo for structure: https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n *\r\n * @class NavGraph\r\n * @private\r\n */\r\nclass NavGraph {\r\n    constructor(navPolygons) {\r\n        this.grid = [];\r\n        this.init = javascript_astar__WEBPACK_IMPORTED_MODULE_0___default().Graph.prototype.init.bind(this);\r\n        this.cleanDirty = javascript_astar__WEBPACK_IMPORTED_MODULE_0___default().Graph.prototype.cleanDirty.bind(this);\r\n        this.markDirty = javascript_astar__WEBPACK_IMPORTED_MODULE_0___default().Graph.prototype.markDirty.bind(this);\r\n        this.toString = javascript_astar__WEBPACK_IMPORTED_MODULE_0___default().Graph.prototype.toString.bind(this);\r\n        this.nodes = navPolygons;\r\n        this.init();\r\n    }\r\n    neighbors(navPolygon) {\r\n        return navPolygon.neighbors;\r\n    }\r\n    navHeuristic(navPolygon1, navPolygon2) {\r\n        return navPolygon1.centroidDistance(navPolygon2);\r\n    }\r\n    destroy() {\r\n        this.cleanDirty();\r\n        this.nodes = [];\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NavGraph);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vbmF2Z3JhcGgudHM/ZWY5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUZBQWlDO0FBQ3JELDBCQUEwQix1RkFBdUM7QUFDakUseUJBQXlCLHNGQUFzQztBQUMvRCx3QkFBd0IscUZBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxRQUFRLEVBQUMiLCJmaWxlIjoiLi9uYXZncmFwaC50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBqc2FzdGFyIGZyb20gXCJqYXZhc2NyaXB0LWFzdGFyXCI7XHJcbi8qKlxyXG4gKiBHcmFwaCBmb3IgamF2YXNjcmlwdC1hc3Rhci4gSXQgaW1wbGVtZW50cyB0aGUgZnVuY3Rpb25hbGl0eSBmb3IgYXN0YXIuIFNlZSBHUFMgdGVzdCBmcm9tIGFzdGFyXHJcbiAqIHJlcG8gZm9yIHN0cnVjdHVyZTogaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9qYXZhc2NyaXB0LWFzdGFyL2Jsb2IvbWFzdGVyL3Rlc3QvdGVzdHMuanNcclxuICpcclxuICogQGNsYXNzIE5hdkdyYXBoXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jbGFzcyBOYXZHcmFwaCB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYXZQb2x5Z29ucykge1xyXG4gICAgICAgIHRoaXMuZ3JpZCA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW5pdCA9IGpzYXN0YXIuR3JhcGgucHJvdG90eXBlLmluaXQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNsZWFuRGlydHkgPSBqc2FzdGFyLkdyYXBoLnByb3RvdHlwZS5jbGVhbkRpcnR5LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5tYXJrRGlydHkgPSBqc2FzdGFyLkdyYXBoLnByb3RvdHlwZS5tYXJrRGlydHkuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0ganNhc3Rhci5HcmFwaC5wcm90b3R5cGUudG9TdHJpbmcuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5vZGVzID0gbmF2UG9seWdvbnM7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcbiAgICBuZWlnaGJvcnMobmF2UG9seWdvbikge1xyXG4gICAgICAgIHJldHVybiBuYXZQb2x5Z29uLm5laWdoYm9ycztcclxuICAgIH1cclxuICAgIG5hdkhldXJpc3RpYyhuYXZQb2x5Z29uMSwgbmF2UG9seWdvbjIpIHtcclxuICAgICAgICByZXR1cm4gbmF2UG9seWdvbjEuY2VudHJvaWREaXN0YW5jZShuYXZQb2x5Z29uMik7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYW5EaXJ0eSgpO1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBOYXZHcmFwaDtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./navgraph.ts\n");

/***/ }),

/***/ "./navmesh.ts":
/*!********************!*\
  !*** ./navmesh.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ NavMesh)\n/* harmony export */ });\n/* harmony import */ var javascript_astar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! javascript-astar */ \"../../../node_modules/javascript-astar/astar.js\");\n/* harmony import */ var javascript_astar__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(javascript_astar__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _navpoly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./navpoly */ \"./navpoly.ts\");\n/* harmony import */ var _navgraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./navgraph */ \"./navgraph.ts\");\n/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./channel */ \"./channel.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./utils.ts\");\n/* harmony import */ var _math_vector_2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math/vector-2 */ \"./math/vector-2.ts\");\n/* harmony import */ var _math_line__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./math/line */ \"./math/line.ts\");\n/* harmony import */ var _math_polygon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./math/polygon */ \"./math/polygon.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The `NavMesh` class is the workhorse that represents a navigation mesh built from a series of\r\n * polygons. Once built, the mesh can be asked for a path from one point to another point. Some\r\n * internal terminology usage:\r\n * - neighbor: a polygon that shares part of an edge with another polygon\r\n * - portal: when two neighbor's have edges that overlap, the portal is the overlapping line segment\r\n * - channel: the path of polygons from starting point to end point\r\n * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the\r\n *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.\r\n */\r\nclass NavMesh {\r\n    /**\r\n     * @param meshPolygonPoints Array where each element is an array of point-like objects that\r\n     * defines a polygon.\r\n     * @param meshShrinkAmount The amount (in pixels) that the navmesh has been shrunk around\r\n     * obstacles (a.k.a the amount obstacles have been expanded).\r\n     */\r\n    constructor(meshPolygonPoints, meshShrinkAmount = 0) {\r\n        this.meshShrinkAmount = meshShrinkAmount;\r\n        // Convert the PolyPoints[] into NavPoly instances.\r\n        const newPolys = meshPolygonPoints.map((polyPoints) => {\r\n            const vectors = polyPoints.map((p) => new _math_vector_2__WEBPACK_IMPORTED_MODULE_5__.default(p.x, p.y));\r\n            return new _math_polygon__WEBPACK_IMPORTED_MODULE_7__.default(vectors);\r\n        });\r\n        this.navPolygons = newPolys.map((polygon, i) => new _navpoly__WEBPACK_IMPORTED_MODULE_1__.default(i, polygon));\r\n        this.calculateNeighbors();\r\n        // Astar graph of connections between polygons\r\n        this.graph = new _navgraph__WEBPACK_IMPORTED_MODULE_2__.default(this.navPolygons);\r\n    }\r\n    /**\r\n     * Get the NavPolys that are in this navmesh.\r\n     */\r\n    getPolygons() {\r\n        return this.navPolygons;\r\n    }\r\n    /**\r\n     * Cleanup method to remove references.\r\n     */\r\n    destroy() {\r\n        this.graph.destroy();\r\n        for (const poly of this.navPolygons)\r\n            poly.destroy();\r\n        this.navPolygons = [];\r\n    }\r\n    /**\r\n     * Find a given start point within the mesh to an end point that may not be accessible in the\r\n     * mesh. This will try to get as close as possible.\r\n     * @param startPoint\r\n     * @param possibleEndPoint\r\n     * @param maxDistance\r\n     */\r\n    findClosestPath(startPoint, possibleEndPoint, maxDistance = Number.MAX_SAFE_INTEGER) {\r\n        // TODO!\r\n    }\r\n    /**\r\n     * Find the closest polygon to the given point. If a fudgeAmount is provided, this will be used to\r\n     * find the closest polygon within the fudgeAmount of the point.\r\n     * @param point\r\n     * @param fudgeAmount\r\n     */\r\n    getPolyFromPoint(point, fudgeAmount = this.meshShrinkAmount) {\r\n        let closestPoly = null;\r\n        let minDistance = Number.MAX_VALUE;\r\n        for (const navPoly of this.navPolygons) {\r\n            const r = navPoly.boundingRadius;\r\n            const d = navPoly.centroid.distance(point);\r\n            if (d < minDistance && d <= r && navPoly.contains(point)) {\r\n                closestPoly = navPoly;\r\n                minDistance = d;\r\n            }\r\n        }\r\n        // If the point wasn't inside a polygon, run a more liberal check that allows a point to be\r\n        // within some fudge factor of the radius of the polygon.\r\n        if (!closestPoly && fudgeAmount > 0) {\r\n            for (const navPoly of this.navPolygons) {\r\n                const r = navPoly.boundingRadius + fudgeAmount;\r\n                const d = navPoly.centroid.distance(point);\r\n                if (d <= r) {\r\n                    const { distance } = this.projectPointToPolygon(point, navPoly);\r\n                    if (distance <= fudgeAmount && distance < minDistance) {\r\n                        closestPoly = navPoly;\r\n                        minDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return closestPoly;\r\n    }\r\n    getPointsInPolys(startVector, endVector, fudge) {\r\n        let startPoly = null;\r\n        let endPoly = null;\r\n        let startDistance = Number.MAX_VALUE;\r\n        let endDistance = Number.MAX_VALUE;\r\n        let d = 0;\r\n        let r = 0;\r\n        let extraCheck = fudge ?? this.meshShrinkAmount;\r\n        // Find the closest poly for the starting and ending point.\r\n        for (const navPoly of this.navPolygons) {\r\n            r = navPoly.boundingRadius;\r\n            d = navPoly.centroid.distance(startVector);\r\n            if (d <= startDistance && d <= r && navPoly.contains(startVector)) {\r\n                startPoly = navPoly;\r\n                startDistance = d;\r\n            }\r\n            d = navPoly.centroid.distance(endVector);\r\n            if (d <= endDistance && d <= r && navPoly.contains(endVector)) {\r\n                endPoly = navPoly;\r\n                endDistance = d;\r\n            }\r\n        }\r\n        // If the end point wasn't inside a polygon, run a more liberal check that allows a point\r\n        // to be within meshShrinkAmount radius of a polygon\r\n        if (!endPoly && this.meshShrinkAmount > 0) {\r\n            for (const navPoly of this.navPolygons) {\r\n                r = navPoly.boundingRadius + this.meshShrinkAmount;\r\n                d = navPoly.centroid.distance(endVector);\r\n                if (d <= r) {\r\n                    const { distance } = this.projectPointToPolygon(endVector, navPoly);\r\n                    if (distance <= this.meshShrinkAmount && distance < endDistance) {\r\n                        endPoly = navPoly;\r\n                        endDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Find a path from the start point to the end point using this nav mesh.\r\n     * @param {object} startPoint A point-like object in the form {x, y}\r\n     * @param {object} endPoint A point-like object in the form {x, y}\r\n     * @returns {Vector2[]|null} An array of points if a path is found, or null if no path\r\n     */\r\n    findPath(startPoint, endPoint) {\r\n        let startPoly = null;\r\n        let endPoly = null;\r\n        let startDistance = Number.MAX_VALUE;\r\n        let endDistance = Number.MAX_VALUE;\r\n        let d, r;\r\n        const startVector = new _math_vector_2__WEBPACK_IMPORTED_MODULE_5__.default(startPoint.x, startPoint.y);\r\n        const endVector = new _math_vector_2__WEBPACK_IMPORTED_MODULE_5__.default(endPoint.x, endPoint.y);\r\n        // Find the closest poly for the starting and ending point\r\n        for (const navPoly of this.navPolygons) {\r\n            r = navPoly.boundingRadius;\r\n            // Start\r\n            d = navPoly.centroid.distance(startVector);\r\n            if (d <= startDistance && d <= r && navPoly.contains(startVector)) {\r\n                startPoly = navPoly;\r\n                startDistance = d;\r\n            }\r\n            // End\r\n            d = navPoly.centroid.distance(endVector);\r\n            if (d <= endDistance && d <= r && navPoly.contains(endVector)) {\r\n                endPoly = navPoly;\r\n                endDistance = d;\r\n            }\r\n        }\r\n        // If the end point wasn't inside a polygon, run a more liberal check that allows a point\r\n        // to be within meshShrinkAmount radius of a polygon\r\n        if (!endPoly && this.meshShrinkAmount > 0) {\r\n            for (const navPoly of this.navPolygons) {\r\n                r = navPoly.boundingRadius + this.meshShrinkAmount;\r\n                d = navPoly.centroid.distance(endVector);\r\n                if (d <= r) {\r\n                    const { distance } = this.projectPointToPolygon(endVector, navPoly);\r\n                    if (distance <= this.meshShrinkAmount && distance < endDistance) {\r\n                        endPoly = navPoly;\r\n                        endDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // No matching polygons locations for the end, so no path found\r\n        // because start point is valid normally, check end point first\r\n        if (!endPoly)\r\n            return null;\r\n        // Same check as above, but for the start point\r\n        if (!startPoly && this.meshShrinkAmount > 0) {\r\n            for (const navPoly of this.navPolygons) {\r\n                // Check if point is within bounding circle to avoid extra projection calculations\r\n                r = navPoly.boundingRadius + this.meshShrinkAmount;\r\n                d = navPoly.centroid.distance(startVector);\r\n                if (d <= r) {\r\n                    // Check if projected point is within range of a polgyon and is closer than the\r\n                    // previous point\r\n                    const { distance } = this.projectPointToPolygon(startVector, navPoly);\r\n                    if (distance <= this.meshShrinkAmount && distance < startDistance) {\r\n                        startPoly = navPoly;\r\n                        startDistance = distance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // No matching polygons locations for the start, so no path found\r\n        if (!startPoly)\r\n            return null;\r\n        // If the start and end polygons are the same, return a direct path\r\n        if (startPoly === endPoly)\r\n            return [startVector, endVector];\r\n        // Search!\r\n        const astarPath = javascript_astar__WEBPACK_IMPORTED_MODULE_0___default().astar.search(this.graph, startPoly, endPoly, {\r\n            heuristic: this.graph.navHeuristic,\r\n        });\r\n        // While the start and end polygons may be valid, no path between them\r\n        if (astarPath.length === 0)\r\n            return null;\r\n        // jsastar drops the first point from the path, but the funnel algorithm needs it\r\n        astarPath.unshift(startPoly);\r\n        // We have a path, so now time for the funnel algorithm\r\n        const channel = new _channel__WEBPACK_IMPORTED_MODULE_3__.default();\r\n        channel.push(startVector);\r\n        for (let i = 0; i < astarPath.length - 1; i++) {\r\n            const navPolygon = astarPath[i];\r\n            const nextNavPolygon = astarPath[i + 1];\r\n            // Find the portal\r\n            let portal = null;\r\n            for (let i = 0; i < navPolygon.neighbors.length; i++) {\r\n                if (navPolygon.neighbors[i].id === nextNavPolygon.id) {\r\n                    portal = navPolygon.portals[i];\r\n                }\r\n            }\r\n            if (!portal)\r\n                throw new Error(\"Path was supposed to be found, but portal is missing!\");\r\n            // Push the portal vertices into the channel\r\n            channel.push(portal.start, portal.end);\r\n        }\r\n        channel.push(endVector);\r\n        // Pull a string along the channel to run the funnel\r\n        channel.stringPull();\r\n        // Clone path, excluding duplicates\r\n        let lastPoint = null;\r\n        const phaserPath = [];\r\n        for (const p of channel.path) {\r\n            const newPoint = p.clone();\r\n            if (!lastPoint || !newPoint.equals(lastPoint))\r\n                phaserPath.push(newPoint);\r\n            lastPoint = newPoint;\r\n        }\r\n        return phaserPath;\r\n    }\r\n    calculateNeighbors() {\r\n        // Fill out the neighbor information for each navpoly\r\n        for (let i = 0; i < this.navPolygons.length; i++) {\r\n            const navPoly = this.navPolygons[i];\r\n            for (let j = i + 1; j < this.navPolygons.length; j++) {\r\n                const otherNavPoly = this.navPolygons[j];\r\n                // Check if the other navpoly is within range to touch\r\n                const d = navPoly.centroid.distance(otherNavPoly.centroid);\r\n                if (d > navPoly.boundingRadius + otherNavPoly.boundingRadius)\r\n                    continue;\r\n                // The are in range, so check each edge pairing\r\n                for (const edge of navPoly.edges) {\r\n                    for (const otherEdge of otherNavPoly.edges) {\r\n                        // If edges aren't collinear, not an option for connecting navpolys\r\n                        if (!(0,_utils__WEBPACK_IMPORTED_MODULE_4__.areCollinear)(edge, otherEdge))\r\n                            continue;\r\n                        // If they are collinear, check if they overlap\r\n                        const overlap = this.getSegmentOverlap(edge, otherEdge);\r\n                        if (!overlap)\r\n                            continue;\r\n                        // Connections are symmetric!\r\n                        navPoly.neighbors.push(otherNavPoly);\r\n                        otherNavPoly.neighbors.push(navPoly);\r\n                        // Calculate the portal between the two polygons - this needs to be in\r\n                        // counter-clockwise order, relative to each polygon\r\n                        const [p1, p2] = overlap;\r\n                        let edgeStartAngle = navPoly.centroid.angle(edge.start);\r\n                        let a1 = navPoly.centroid.angle(overlap[0]);\r\n                        let a2 = navPoly.centroid.angle(overlap[1]);\r\n                        let d1 = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.angleDifference)(edgeStartAngle, a1);\r\n                        let d2 = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.angleDifference)(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            navPoly.portals.push(new _math_line__WEBPACK_IMPORTED_MODULE_6__.default(p1.x, p1.y, p2.x, p2.y));\r\n                        }\r\n                        else {\r\n                            navPoly.portals.push(new _math_line__WEBPACK_IMPORTED_MODULE_6__.default(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                        edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);\r\n                        a1 = otherNavPoly.centroid.angle(overlap[0]);\r\n                        a2 = otherNavPoly.centroid.angle(overlap[1]);\r\n                        d1 = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.angleDifference)(edgeStartAngle, a1);\r\n                        d2 = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.angleDifference)(edgeStartAngle, a2);\r\n                        if (d1 < d2) {\r\n                            otherNavPoly.portals.push(new _math_line__WEBPACK_IMPORTED_MODULE_6__.default(p1.x, p1.y, p2.x, p2.y));\r\n                        }\r\n                        else {\r\n                            otherNavPoly.portals.push(new _math_line__WEBPACK_IMPORTED_MODULE_6__.default(p2.x, p2.y, p1.x, p1.y));\r\n                        }\r\n                        // Two convex polygons shouldn't be connected more than once! (Unless\r\n                        // there are unnecessary vertices...)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Check two collinear line segments to see if they overlap by sorting the points.\r\n    // Algorithm source: http://stackoverflow.com/a/17152247\r\n    getSegmentOverlap(line1, line2) {\r\n        const points = [\r\n            { line: line1, point: line1.start },\r\n            { line: line1, point: line1.end },\r\n            { line: line2, point: line2.start },\r\n            { line: line2, point: line2.end },\r\n        ];\r\n        points.sort(function (a, b) {\r\n            if (a.point.x < b.point.x)\r\n                return -1;\r\n            else if (a.point.x > b.point.x)\r\n                return 1;\r\n            else {\r\n                if (a.point.y < b.point.y)\r\n                    return -1;\r\n                else if (a.point.y > b.point.y)\r\n                    return 1;\r\n                else\r\n                    return 0;\r\n            }\r\n        });\r\n        // If the first two points in the array come from the same line, no overlap\r\n        const noOverlap = points[0].line === points[1].line;\r\n        // If the two middle points in the array are the same coordinates, then there is a\r\n        // single point of overlap.\r\n        const singlePointOverlap = points[1].point.equals(points[2].point);\r\n        if (noOverlap || singlePointOverlap)\r\n            return null;\r\n        else\r\n            return [points[1].point, points[2].point];\r\n    }\r\n    /**\r\n     * Project a point onto a polygon in the shortest distance possible.\r\n     *\r\n     * @param {Phaser.Point} point The point to project\r\n     * @param {NavPoly} navPoly The navigation polygon to test against\r\n     * @returns {{point: Phaser.Point, distance: number}}\r\n     */\r\n    projectPointToPolygon(point, navPoly) {\r\n        let closestProjection = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        for (const edge of navPoly.edges) {\r\n            const projectedPoint = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.projectPointToEdge)(point, edge);\r\n            const d = point.distance(projectedPoint);\r\n            if (closestProjection === null || d < closestDistance) {\r\n                closestDistance = d;\r\n                closestProjection = projectedPoint;\r\n            }\r\n        }\r\n        return { point: closestProjection, distance: closestDistance };\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vbmF2bWVzaC50cz8xNDE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDUDtBQUNFO0FBQ0Y7QUFDNEM7QUFDdEM7QUFDUDtBQUNNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtREFBTztBQUM3RCx1QkFBdUIsa0RBQU87QUFDOUIsU0FBUztBQUNULDREQUE0RCw2Q0FBTztBQUNuRTtBQUNBO0FBQ0EseUJBQXlCLDhDQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU8sNkNBQTZDO0FBQ25FLGVBQWUsT0FBTywyQ0FBMkM7QUFDakUsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbURBQU87QUFDdkMsOEJBQThCLG1EQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvRUFBb0I7QUFDOUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUFPO0FBQ25DO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0EsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1REFBZTtBQUNoRCxpQ0FBaUMsdURBQWU7QUFDaEQ7QUFDQSxxREFBcUQsK0NBQUk7QUFDekQ7QUFDQTtBQUNBLHFEQUFxRCwrQ0FBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1REFBZTtBQUM1Qyw2QkFBNkIsdURBQWU7QUFDNUM7QUFDQSwwREFBMEQsK0NBQUk7QUFDOUQ7QUFDQTtBQUNBLDBEQUEwRCwrQ0FBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtDQUFrQztBQUMvQyxhQUFhLGdDQUFnQztBQUM3QyxhQUFhLGtDQUFrQztBQUMvQyxhQUFhLGdDQUFnQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsUUFBUTtBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwREFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EiLCJmaWxlIjoiLi9uYXZtZXNoLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGpzYXN0YXIgZnJvbSBcImphdmFzY3JpcHQtYXN0YXJcIjtcclxuaW1wb3J0IE5hdlBvbHkgZnJvbSBcIi4vbmF2cG9seVwiO1xyXG5pbXBvcnQgTmF2R3JhcGggZnJvbSBcIi4vbmF2Z3JhcGhcIjtcclxuaW1wb3J0IENoYW5uZWwgZnJvbSBcIi4vY2hhbm5lbFwiO1xyXG5pbXBvcnQgeyBhbmdsZURpZmZlcmVuY2UsIGFyZUNvbGxpbmVhciwgcHJvamVjdFBvaW50VG9FZGdlIH0gZnJvbSBcIi4vdXRpbHNcIjtcclxuaW1wb3J0IFZlY3RvcjIgZnJvbSBcIi4vbWF0aC92ZWN0b3ItMlwiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi9tYXRoL2xpbmVcIjtcclxuaW1wb3J0IFBvbHlnb24gZnJvbSBcIi4vbWF0aC9wb2x5Z29uXCI7XHJcbi8qKlxyXG4gKiBUaGUgYE5hdk1lc2hgIGNsYXNzIGlzIHRoZSB3b3JraG9yc2UgdGhhdCByZXByZXNlbnRzIGEgbmF2aWdhdGlvbiBtZXNoIGJ1aWx0IGZyb20gYSBzZXJpZXMgb2ZcclxuICogcG9seWdvbnMuIE9uY2UgYnVpbHQsIHRoZSBtZXNoIGNhbiBiZSBhc2tlZCBmb3IgYSBwYXRoIGZyb20gb25lIHBvaW50IHRvIGFub3RoZXIgcG9pbnQuIFNvbWVcclxuICogaW50ZXJuYWwgdGVybWlub2xvZ3kgdXNhZ2U6XHJcbiAqIC0gbmVpZ2hib3I6IGEgcG9seWdvbiB0aGF0IHNoYXJlcyBwYXJ0IG9mIGFuIGVkZ2Ugd2l0aCBhbm90aGVyIHBvbHlnb25cclxuICogLSBwb3J0YWw6IHdoZW4gdHdvIG5laWdoYm9yJ3MgaGF2ZSBlZGdlcyB0aGF0IG92ZXJsYXAsIHRoZSBwb3J0YWwgaXMgdGhlIG92ZXJsYXBwaW5nIGxpbmUgc2VnbWVudFxyXG4gKiAtIGNoYW5uZWw6IHRoZSBwYXRoIG9mIHBvbHlnb25zIGZyb20gc3RhcnRpbmcgcG9pbnQgdG8gZW5kIHBvaW50XHJcbiAqIC0gcHVsbCB0aGUgc3RyaW5nOiBydW4gdGhlIGZ1bm5lbCBhbGdvcml0aG0gb24gdGhlIGNoYW5uZWwgc28gdGhhdCB0aGUgcGF0aCBodWdzIHRoZSBlZGdlcyBvZiB0aGVcclxuICogICBjaGFubmVsLiBFcXVpdmFsZW50IHRvIGhhdmluZyBhIHN0cmluZyBzbmFraW5nIHRocm91Z2ggYSBoYWxsd2F5IGFuZCB0aGVuIHB1bGxpbmcgaXQgdGF1dC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdk1lc2gge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbWVzaFBvbHlnb25Qb2ludHMgQXJyYXkgd2hlcmUgZWFjaCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIHBvaW50LWxpa2Ugb2JqZWN0cyB0aGF0XHJcbiAgICAgKiBkZWZpbmVzIGEgcG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBtZXNoU2hyaW5rQW1vdW50IFRoZSBhbW91bnQgKGluIHBpeGVscykgdGhhdCB0aGUgbmF2bWVzaCBoYXMgYmVlbiBzaHJ1bmsgYXJvdW5kXHJcbiAgICAgKiBvYnN0YWNsZXMgKGEuay5hIHRoZSBhbW91bnQgb2JzdGFjbGVzIGhhdmUgYmVlbiBleHBhbmRlZCkuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1lc2hQb2x5Z29uUG9pbnRzLCBtZXNoU2hyaW5rQW1vdW50ID0gMCkge1xyXG4gICAgICAgIHRoaXMubWVzaFNocmlua0Ftb3VudCA9IG1lc2hTaHJpbmtBbW91bnQ7XHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgUG9seVBvaW50c1tdIGludG8gTmF2UG9seSBpbnN0YW5jZXMuXHJcbiAgICAgICAgY29uc3QgbmV3UG9seXMgPSBtZXNoUG9seWdvblBvaW50cy5tYXAoKHBvbHlQb2ludHMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdmVjdG9ycyA9IHBvbHlQb2ludHMubWFwKChwKSA9PiBuZXcgVmVjdG9yMihwLngsIHAueSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24odmVjdG9ycyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5uYXZQb2x5Z29ucyA9IG5ld1BvbHlzLm1hcCgocG9seWdvbiwgaSkgPT4gbmV3IE5hdlBvbHkoaSwgcG9seWdvbikpO1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlTmVpZ2hib3JzKCk7XHJcbiAgICAgICAgLy8gQXN0YXIgZ3JhcGggb2YgY29ubmVjdGlvbnMgYmV0d2VlbiBwb2x5Z29uc1xyXG4gICAgICAgIHRoaXMuZ3JhcGggPSBuZXcgTmF2R3JhcGgodGhpcy5uYXZQb2x5Z29ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgTmF2UG9seXMgdGhhdCBhcmUgaW4gdGhpcyBuYXZtZXNoLlxyXG4gICAgICovXHJcbiAgICBnZXRQb2x5Z29ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYXZQb2x5Z29ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYW51cCBtZXRob2QgdG8gcmVtb3ZlIHJlZmVyZW5jZXMuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5ncmFwaC5kZXN0cm95KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBwb2x5IG9mIHRoaXMubmF2UG9seWdvbnMpXHJcbiAgICAgICAgICAgIHBvbHkuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMubmF2UG9seWdvbnMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCBhIGdpdmVuIHN0YXJ0IHBvaW50IHdpdGhpbiB0aGUgbWVzaCB0byBhbiBlbmQgcG9pbnQgdGhhdCBtYXkgbm90IGJlIGFjY2Vzc2libGUgaW4gdGhlXHJcbiAgICAgKiBtZXNoLiBUaGlzIHdpbGwgdHJ5IHRvIGdldCBhcyBjbG9zZSBhcyBwb3NzaWJsZS5cclxuICAgICAqIEBwYXJhbSBzdGFydFBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9zc2libGVFbmRQb2ludFxyXG4gICAgICogQHBhcmFtIG1heERpc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIGZpbmRDbG9zZXN0UGF0aChzdGFydFBvaW50LCBwb3NzaWJsZUVuZFBvaW50LCBtYXhEaXN0YW5jZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XHJcbiAgICAgICAgLy8gVE9ETyFcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgY2xvc2VzdCBwb2x5Z29uIHRvIHRoZSBnaXZlbiBwb2ludC4gSWYgYSBmdWRnZUFtb3VudCBpcyBwcm92aWRlZCwgdGhpcyB3aWxsIGJlIHVzZWQgdG9cclxuICAgICAqIGZpbmQgdGhlIGNsb3Nlc3QgcG9seWdvbiB3aXRoaW4gdGhlIGZ1ZGdlQW1vdW50IG9mIHRoZSBwb2ludC5cclxuICAgICAqIEBwYXJhbSBwb2ludFxyXG4gICAgICogQHBhcmFtIGZ1ZGdlQW1vdW50XHJcbiAgICAgKi9cclxuICAgIGdldFBvbHlGcm9tUG9pbnQocG9pbnQsIGZ1ZGdlQW1vdW50ID0gdGhpcy5tZXNoU2hyaW5rQW1vdW50KSB7XHJcbiAgICAgICAgbGV0IGNsb3Nlc3RQb2x5ID0gbnVsbDtcclxuICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGZvciAoY29uc3QgbmF2UG9seSBvZiB0aGlzLm5hdlBvbHlnb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBuYXZQb2x5LmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgICAgICAgICBjb25zdCBkID0gbmF2UG9seS5jZW50cm9pZC5kaXN0YW5jZShwb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UgJiYgZCA8PSByICYmIG5hdlBvbHkuY29udGFpbnMocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0UG9seSA9IG5hdlBvbHk7XHJcbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIHBvaW50IHdhc24ndCBpbnNpZGUgYSBwb2x5Z29uLCBydW4gYSBtb3JlIGxpYmVyYWwgY2hlY2sgdGhhdCBhbGxvd3MgYSBwb2ludCB0byBiZVxyXG4gICAgICAgIC8vIHdpdGhpbiBzb21lIGZ1ZGdlIGZhY3RvciBvZiB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uLlxyXG4gICAgICAgIGlmICghY2xvc2VzdFBvbHkgJiYgZnVkZ2VBbW91bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmF2UG9seSBvZiB0aGlzLm5hdlBvbHlnb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByID0gbmF2UG9seS5ib3VuZGluZ1JhZGl1cyArIGZ1ZGdlQW1vdW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IG5hdlBvbHkuY2VudHJvaWQuZGlzdGFuY2UocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgPD0gcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGlzdGFuY2UgfSA9IHRoaXMucHJvamVjdFBvaW50VG9Qb2x5Z29uKHBvaW50LCBuYXZQb2x5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPD0gZnVkZ2VBbW91bnQgJiYgZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0UG9seSA9IG5hdlBvbHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9zZXN0UG9seTtcclxuICAgIH1cclxuICAgIGdldFBvaW50c0luUG9seXMoc3RhcnRWZWN0b3IsIGVuZFZlY3RvciwgZnVkZ2UpIHtcclxuICAgICAgICBsZXQgc3RhcnRQb2x5ID0gbnVsbDtcclxuICAgICAgICBsZXQgZW5kUG9seSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHN0YXJ0RGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGxldCBlbmREaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IGQgPSAwO1xyXG4gICAgICAgIGxldCByID0gMDtcclxuICAgICAgICBsZXQgZXh0cmFDaGVjayA9IGZ1ZGdlID8/IHRoaXMubWVzaFNocmlua0Ftb3VudDtcclxuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHBvbHkgZm9yIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50LlxyXG4gICAgICAgIGZvciAoY29uc3QgbmF2UG9seSBvZiB0aGlzLm5hdlBvbHlnb25zKSB7XHJcbiAgICAgICAgICAgIHIgPSBuYXZQb2x5LmJvdW5kaW5nUmFkaXVzO1xyXG4gICAgICAgICAgICBkID0gbmF2UG9seS5jZW50cm9pZC5kaXN0YW5jZShzdGFydFZlY3Rvcik7XHJcbiAgICAgICAgICAgIGlmIChkIDw9IHN0YXJ0RGlzdGFuY2UgJiYgZCA8PSByICYmIG5hdlBvbHkuY29udGFpbnMoc3RhcnRWZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFBvbHkgPSBuYXZQb2x5O1xyXG4gICAgICAgICAgICAgICAgc3RhcnREaXN0YW5jZSA9IGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZCA9IG5hdlBvbHkuY2VudHJvaWQuZGlzdGFuY2UoZW5kVmVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKGQgPD0gZW5kRGlzdGFuY2UgJiYgZCA8PSByICYmIG5hdlBvbHkuY29udGFpbnMoZW5kVmVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kUG9seSA9IG5hdlBvbHk7XHJcbiAgICAgICAgICAgICAgICBlbmREaXN0YW5jZSA9IGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIGVuZCBwb2ludCB3YXNuJ3QgaW5zaWRlIGEgcG9seWdvbiwgcnVuIGEgbW9yZSBsaWJlcmFsIGNoZWNrIHRoYXQgYWxsb3dzIGEgcG9pbnRcclxuICAgICAgICAvLyB0byBiZSB3aXRoaW4gbWVzaFNocmlua0Ftb3VudCByYWRpdXMgb2YgYSBwb2x5Z29uXHJcbiAgICAgICAgaWYgKCFlbmRQb2x5ICYmIHRoaXMubWVzaFNocmlua0Ftb3VudCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBuYXZQb2x5IG9mIHRoaXMubmF2UG9seWdvbnMpIHtcclxuICAgICAgICAgICAgICAgIHIgPSBuYXZQb2x5LmJvdW5kaW5nUmFkaXVzICsgdGhpcy5tZXNoU2hyaW5rQW1vdW50O1xyXG4gICAgICAgICAgICAgICAgZCA9IG5hdlBvbHkuY2VudHJvaWQuZGlzdGFuY2UoZW5kVmVjdG9yKTtcclxuICAgICAgICAgICAgICAgIGlmIChkIDw9IHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRpc3RhbmNlIH0gPSB0aGlzLnByb2plY3RQb2ludFRvUG9seWdvbihlbmRWZWN0b3IsIG5hdlBvbHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSB0aGlzLm1lc2hTaHJpbmtBbW91bnQgJiYgZGlzdGFuY2UgPCBlbmREaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRQb2x5ID0gbmF2UG9seTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgYSBwYXRoIGZyb20gdGhlIHN0YXJ0IHBvaW50IHRvIHRoZSBlbmQgcG9pbnQgdXNpbmcgdGhpcyBuYXYgbWVzaC5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdGFydFBvaW50IEEgcG9pbnQtbGlrZSBvYmplY3QgaW4gdGhlIGZvcm0ge3gsIHl9XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZW5kUG9pbnQgQSBwb2ludC1saWtlIG9iamVjdCBpbiB0aGUgZm9ybSB7eCwgeX1cclxuICAgICAqIEByZXR1cm5zIHtWZWN0b3IyW118bnVsbH0gQW4gYXJyYXkgb2YgcG9pbnRzIGlmIGEgcGF0aCBpcyBmb3VuZCwgb3IgbnVsbCBpZiBubyBwYXRoXHJcbiAgICAgKi9cclxuICAgIGZpbmRQYXRoKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0UG9seSA9IG51bGw7XHJcbiAgICAgICAgbGV0IGVuZFBvbHkgPSBudWxsO1xyXG4gICAgICAgIGxldCBzdGFydERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgZW5kRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGxldCBkLCByO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VmVjdG9yID0gbmV3IFZlY3RvcjIoc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnkpO1xyXG4gICAgICAgIGNvbnN0IGVuZFZlY3RvciA9IG5ldyBWZWN0b3IyKGVuZFBvaW50LngsIGVuZFBvaW50LnkpO1xyXG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9seSBmb3IgdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRcclxuICAgICAgICBmb3IgKGNvbnN0IG5hdlBvbHkgb2YgdGhpcy5uYXZQb2x5Z29ucykge1xyXG4gICAgICAgICAgICByID0gbmF2UG9seS5ib3VuZGluZ1JhZGl1cztcclxuICAgICAgICAgICAgLy8gU3RhcnRcclxuICAgICAgICAgICAgZCA9IG5hdlBvbHkuY2VudHJvaWQuZGlzdGFuY2Uoc3RhcnRWZWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoZCA8PSBzdGFydERpc3RhbmNlICYmIGQgPD0gciAmJiBuYXZQb2x5LmNvbnRhaW5zKHN0YXJ0VmVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQb2x5ID0gbmF2UG9seTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0RGlzdGFuY2UgPSBkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEVuZFxyXG4gICAgICAgICAgICBkID0gbmF2UG9seS5jZW50cm9pZC5kaXN0YW5jZShlbmRWZWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoZCA8PSBlbmREaXN0YW5jZSAmJiBkIDw9IHIgJiYgbmF2UG9seS5jb250YWlucyhlbmRWZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRQb2x5ID0gbmF2UG9seTtcclxuICAgICAgICAgICAgICAgIGVuZERpc3RhbmNlID0gZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgZW5kIHBvaW50IHdhc24ndCBpbnNpZGUgYSBwb2x5Z29uLCBydW4gYSBtb3JlIGxpYmVyYWwgY2hlY2sgdGhhdCBhbGxvd3MgYSBwb2ludFxyXG4gICAgICAgIC8vIHRvIGJlIHdpdGhpbiBtZXNoU2hyaW5rQW1vdW50IHJhZGl1cyBvZiBhIHBvbHlnb25cclxuICAgICAgICBpZiAoIWVuZFBvbHkgJiYgdGhpcy5tZXNoU2hyaW5rQW1vdW50ID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hdlBvbHkgb2YgdGhpcy5uYXZQb2x5Z29ucykge1xyXG4gICAgICAgICAgICAgICAgciA9IG5hdlBvbHkuYm91bmRpbmdSYWRpdXMgKyB0aGlzLm1lc2hTaHJpbmtBbW91bnQ7XHJcbiAgICAgICAgICAgICAgICBkID0gbmF2UG9seS5jZW50cm9pZC5kaXN0YW5jZShlbmRWZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQgPD0gcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGlzdGFuY2UgfSA9IHRoaXMucHJvamVjdFBvaW50VG9Qb2x5Z29uKGVuZFZlY3RvciwgbmF2UG9seSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IHRoaXMubWVzaFNocmlua0Ftb3VudCAmJiBkaXN0YW5jZSA8IGVuZERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvbHkgPSBuYXZQb2x5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmREaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBObyBtYXRjaGluZyBwb2x5Z29ucyBsb2NhdGlvbnMgZm9yIHRoZSBlbmQsIHNvIG5vIHBhdGggZm91bmRcclxuICAgICAgICAvLyBiZWNhdXNlIHN0YXJ0IHBvaW50IGlzIHZhbGlkIG5vcm1hbGx5LCBjaGVjayBlbmQgcG9pbnQgZmlyc3RcclxuICAgICAgICBpZiAoIWVuZFBvbHkpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIC8vIFNhbWUgY2hlY2sgYXMgYWJvdmUsIGJ1dCBmb3IgdGhlIHN0YXJ0IHBvaW50XHJcbiAgICAgICAgaWYgKCFzdGFydFBvbHkgJiYgdGhpcy5tZXNoU2hyaW5rQW1vdW50ID4gMCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hdlBvbHkgb2YgdGhpcy5uYXZQb2x5Z29ucykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcG9pbnQgaXMgd2l0aGluIGJvdW5kaW5nIGNpcmNsZSB0byBhdm9pZCBleHRyYSBwcm9qZWN0aW9uIGNhbGN1bGF0aW9uc1xyXG4gICAgICAgICAgICAgICAgciA9IG5hdlBvbHkuYm91bmRpbmdSYWRpdXMgKyB0aGlzLm1lc2hTaHJpbmtBbW91bnQ7XHJcbiAgICAgICAgICAgICAgICBkID0gbmF2UG9seS5jZW50cm9pZC5kaXN0YW5jZShzdGFydFZlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA8PSByKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcHJvamVjdGVkIHBvaW50IGlzIHdpdGhpbiByYW5nZSBvZiBhIHBvbGd5b24gYW5kIGlzIGNsb3NlciB0aGFuIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkaXN0YW5jZSB9ID0gdGhpcy5wcm9qZWN0UG9pbnRUb1BvbHlnb24oc3RhcnRWZWN0b3IsIG5hdlBvbHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSB0aGlzLm1lc2hTaHJpbmtBbW91bnQgJiYgZGlzdGFuY2UgPCBzdGFydERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9seSA9IG5hdlBvbHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm8gbWF0Y2hpbmcgcG9seWdvbnMgbG9jYXRpb25zIGZvciB0aGUgc3RhcnQsIHNvIG5vIHBhdGggZm91bmRcclxuICAgICAgICBpZiAoIXN0YXJ0UG9seSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgLy8gSWYgdGhlIHN0YXJ0IGFuZCBlbmQgcG9seWdvbnMgYXJlIHRoZSBzYW1lLCByZXR1cm4gYSBkaXJlY3QgcGF0aFxyXG4gICAgICAgIGlmIChzdGFydFBvbHkgPT09IGVuZFBvbHkpXHJcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnRWZWN0b3IsIGVuZFZlY3Rvcl07XHJcbiAgICAgICAgLy8gU2VhcmNoIVxyXG4gICAgICAgIGNvbnN0IGFzdGFyUGF0aCA9IGpzYXN0YXIuYXN0YXIuc2VhcmNoKHRoaXMuZ3JhcGgsIHN0YXJ0UG9seSwgZW5kUG9seSwge1xyXG4gICAgICAgICAgICBoZXVyaXN0aWM6IHRoaXMuZ3JhcGgubmF2SGV1cmlzdGljLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdoaWxlIHRoZSBzdGFydCBhbmQgZW5kIHBvbHlnb25zIG1heSBiZSB2YWxpZCwgbm8gcGF0aCBiZXR3ZWVuIHRoZW1cclxuICAgICAgICBpZiAoYXN0YXJQYXRoLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgLy8ganNhc3RhciBkcm9wcyB0aGUgZmlyc3QgcG9pbnQgZnJvbSB0aGUgcGF0aCwgYnV0IHRoZSBmdW5uZWwgYWxnb3JpdGhtIG5lZWRzIGl0XHJcbiAgICAgICAgYXN0YXJQYXRoLnVuc2hpZnQoc3RhcnRQb2x5KTtcclxuICAgICAgICAvLyBXZSBoYXZlIGEgcGF0aCwgc28gbm93IHRpbWUgZm9yIHRoZSBmdW5uZWwgYWxnb3JpdGhtXHJcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XHJcbiAgICAgICAgY2hhbm5lbC5wdXNoKHN0YXJ0VmVjdG9yKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdGFyUGF0aC5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmF2UG9seWdvbiA9IGFzdGFyUGF0aFtpXTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dE5hdlBvbHlnb24gPSBhc3RhclBhdGhbaSArIDFdO1xyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBwb3J0YWxcclxuICAgICAgICAgICAgbGV0IHBvcnRhbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmF2UG9seWdvbi5uZWlnaGJvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChuYXZQb2x5Z29uLm5laWdoYm9yc1tpXS5pZCA9PT0gbmV4dE5hdlBvbHlnb24uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3J0YWwgPSBuYXZQb2x5Z29uLnBvcnRhbHNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFwb3J0YWwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIHdhcyBzdXBwb3NlZCB0byBiZSBmb3VuZCwgYnV0IHBvcnRhbCBpcyBtaXNzaW5nIVwiKTtcclxuICAgICAgICAgICAgLy8gUHVzaCB0aGUgcG9ydGFsIHZlcnRpY2VzIGludG8gdGhlIGNoYW5uZWxcclxuICAgICAgICAgICAgY2hhbm5lbC5wdXNoKHBvcnRhbC5zdGFydCwgcG9ydGFsLmVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYW5uZWwucHVzaChlbmRWZWN0b3IpO1xyXG4gICAgICAgIC8vIFB1bGwgYSBzdHJpbmcgYWxvbmcgdGhlIGNoYW5uZWwgdG8gcnVuIHRoZSBmdW5uZWxcclxuICAgICAgICBjaGFubmVsLnN0cmluZ1B1bGwoKTtcclxuICAgICAgICAvLyBDbG9uZSBwYXRoLCBleGNsdWRpbmcgZHVwbGljYXRlc1xyXG4gICAgICAgIGxldCBsYXN0UG9pbnQgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHBoYXNlclBhdGggPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgY2hhbm5lbC5wYXRoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1BvaW50ID0gcC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAoIWxhc3RQb2ludCB8fCAhbmV3UG9pbnQuZXF1YWxzKGxhc3RQb2ludCkpXHJcbiAgICAgICAgICAgICAgICBwaGFzZXJQYXRoLnB1c2gobmV3UG9pbnQpO1xyXG4gICAgICAgICAgICBsYXN0UG9pbnQgPSBuZXdQb2ludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBoYXNlclBhdGg7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVOZWlnaGJvcnMoKSB7XHJcbiAgICAgICAgLy8gRmlsbCBvdXQgdGhlIG5laWdoYm9yIGluZm9ybWF0aW9uIGZvciBlYWNoIG5hdnBvbHlcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmF2UG9seWdvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmF2UG9seSA9IHRoaXMubmF2UG9seWdvbnNbaV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHRoaXMubmF2UG9seWdvbnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyTmF2UG9seSA9IHRoaXMubmF2UG9seWdvbnNbal07XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgb3RoZXIgbmF2cG9seSBpcyB3aXRoaW4gcmFuZ2UgdG8gdG91Y2hcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBuYXZQb2x5LmNlbnRyb2lkLmRpc3RhbmNlKG90aGVyTmF2UG9seS5jZW50cm9pZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA+IG5hdlBvbHkuYm91bmRpbmdSYWRpdXMgKyBvdGhlck5hdlBvbHkuYm91bmRpbmdSYWRpdXMpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJlIGluIHJhbmdlLCBzbyBjaGVjayBlYWNoIGVkZ2UgcGFpcmluZ1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlZGdlIG9mIG5hdlBvbHkuZWRnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG90aGVyRWRnZSBvZiBvdGhlck5hdlBvbHkuZWRnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZWRnZXMgYXJlbid0IGNvbGxpbmVhciwgbm90IGFuIG9wdGlvbiBmb3IgY29ubmVjdGluZyBuYXZwb2x5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZUNvbGxpbmVhcihlZGdlLCBvdGhlckVkZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIGNvbGxpbmVhciwgY2hlY2sgaWYgdGhleSBvdmVybGFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXAgPSB0aGlzLmdldFNlZ21lbnRPdmVybGFwKGVkZ2UsIG90aGVyRWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3ZlcmxhcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25uZWN0aW9ucyBhcmUgc3ltbWV0cmljIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZQb2x5Lm5laWdoYm9ycy5wdXNoKG90aGVyTmF2UG9seSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTmF2UG9seS5uZWlnaGJvcnMucHVzaChuYXZQb2x5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3J0YWwgYmV0d2VlbiB0aGUgdHdvIHBvbHlnb25zIC0gdGhpcyBuZWVkcyB0byBiZSBpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlciwgcmVsYXRpdmUgdG8gZWFjaCBwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtwMSwgcDJdID0gb3ZlcmxhcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVkZ2VTdGFydEFuZ2xlID0gbmF2UG9seS5jZW50cm9pZC5hbmdsZShlZGdlLnN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGExID0gbmF2UG9seS5jZW50cm9pZC5hbmdsZShvdmVybGFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGEyID0gbmF2UG9seS5jZW50cm9pZC5hbmdsZShvdmVybGFwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGQxID0gYW5nbGVEaWZmZXJlbmNlKGVkZ2VTdGFydEFuZ2xlLCBhMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkMiA9IGFuZ2xlRGlmZmVyZW5jZShlZGdlU3RhcnRBbmdsZSwgYTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZDEgPCBkMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2UG9seS5wb3J0YWxzLnB1c2gobmV3IExpbmUocDEueCwgcDEueSwgcDIueCwgcDIueSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2UG9seS5wb3J0YWxzLnB1c2gobmV3IExpbmUocDIueCwgcDIueSwgcDEueCwgcDEueSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VTdGFydEFuZ2xlID0gb3RoZXJOYXZQb2x5LmNlbnRyb2lkLmFuZ2xlKG90aGVyRWRnZS5zdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGExID0gb3RoZXJOYXZQb2x5LmNlbnRyb2lkLmFuZ2xlKG92ZXJsYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhMiA9IG90aGVyTmF2UG9seS5jZW50cm9pZC5hbmdsZShvdmVybGFwWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZDEgPSBhbmdsZURpZmZlcmVuY2UoZWRnZVN0YXJ0QW5nbGUsIGExKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZDIgPSBhbmdsZURpZmZlcmVuY2UoZWRnZVN0YXJ0QW5nbGUsIGEyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQxIDwgZDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyTmF2UG9seS5wb3J0YWxzLnB1c2gobmV3IExpbmUocDEueCwgcDEueSwgcDIueCwgcDIueSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJOYXZQb2x5LnBvcnRhbHMucHVzaChuZXcgTGluZShwMi54LCBwMi55LCBwMS54LCBwMS55KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHdvIGNvbnZleCBwb2x5Z29ucyBzaG91bGRuJ3QgYmUgY29ubmVjdGVkIG1vcmUgdGhhbiBvbmNlISAoVW5sZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSB1bm5lY2Vzc2FyeSB2ZXJ0aWNlcy4uLilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayB0d28gY29sbGluZWFyIGxpbmUgc2VnbWVudHMgdG8gc2VlIGlmIHRoZXkgb3ZlcmxhcCBieSBzb3J0aW5nIHRoZSBwb2ludHMuXHJcbiAgICAvLyBBbGdvcml0aG0gc291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzE1MjI0N1xyXG4gICAgZ2V0U2VnbWVudE92ZXJsYXAobGluZTEsIGxpbmUyKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW1xyXG4gICAgICAgICAgICB7IGxpbmU6IGxpbmUxLCBwb2ludDogbGluZTEuc3RhcnQgfSxcclxuICAgICAgICAgICAgeyBsaW5lOiBsaW5lMSwgcG9pbnQ6IGxpbmUxLmVuZCB9LFxyXG4gICAgICAgICAgICB7IGxpbmU6IGxpbmUyLCBwb2ludDogbGluZTIuc3RhcnQgfSxcclxuICAgICAgICAgICAgeyBsaW5lOiBsaW5lMiwgcG9pbnQ6IGxpbmUyLmVuZCB9LFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcG9pbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYgKGEucG9pbnQueCA8IGIucG9pbnQueClcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoYS5wb2ludC54ID4gYi5wb2ludC54KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEucG9pbnQueSA8IGIucG9pbnQueSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhLnBvaW50LnkgPiBiLnBvaW50LnkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgdHdvIHBvaW50cyBpbiB0aGUgYXJyYXkgY29tZSBmcm9tIHRoZSBzYW1lIGxpbmUsIG5vIG92ZXJsYXBcclxuICAgICAgICBjb25zdCBub092ZXJsYXAgPSBwb2ludHNbMF0ubGluZSA9PT0gcG9pbnRzWzFdLmxpbmU7XHJcbiAgICAgICAgLy8gSWYgdGhlIHR3byBtaWRkbGUgcG9pbnRzIGluIHRoZSBhcnJheSBhcmUgdGhlIHNhbWUgY29vcmRpbmF0ZXMsIHRoZW4gdGhlcmUgaXMgYVxyXG4gICAgICAgIC8vIHNpbmdsZSBwb2ludCBvZiBvdmVybGFwLlxyXG4gICAgICAgIGNvbnN0IHNpbmdsZVBvaW50T3ZlcmxhcCA9IHBvaW50c1sxXS5wb2ludC5lcXVhbHMocG9pbnRzWzJdLnBvaW50KTtcclxuICAgICAgICBpZiAobm9PdmVybGFwIHx8IHNpbmdsZVBvaW50T3ZlcmxhcClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gW3BvaW50c1sxXS5wb2ludCwgcG9pbnRzWzJdLnBvaW50XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdCBhIHBvaW50IG9udG8gYSBwb2x5Z29uIGluIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBwb3NzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BoYXNlci5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIHByb2plY3RcclxuICAgICAqIEBwYXJhbSB7TmF2UG9seX0gbmF2UG9seSBUaGUgbmF2aWdhdGlvbiBwb2x5Z29uIHRvIHRlc3QgYWdhaW5zdFxyXG4gICAgICogQHJldHVybnMge3twb2ludDogUGhhc2VyLlBvaW50LCBkaXN0YW5jZTogbnVtYmVyfX1cclxuICAgICAqL1xyXG4gICAgcHJvamVjdFBvaW50VG9Qb2x5Z29uKHBvaW50LCBuYXZQb2x5KSB7XHJcbiAgICAgICAgbGV0IGNsb3Nlc3RQcm9qZWN0aW9uID0gbnVsbDtcclxuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgbmF2UG9seS5lZGdlcykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ZWRQb2ludCA9IHByb2plY3RQb2ludFRvRWRnZShwb2ludCwgZWRnZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSBwb2ludC5kaXN0YW5jZShwcm9qZWN0ZWRQb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UHJvamVjdGlvbiA9PT0gbnVsbCB8fCBkIDwgY2xvc2VzdERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkO1xyXG4gICAgICAgICAgICAgICAgY2xvc2VzdFByb2plY3Rpb24gPSBwcm9qZWN0ZWRQb2ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBwb2ludDogY2xvc2VzdFByb2plY3Rpb24sIGRpc3RhbmNlOiBjbG9zZXN0RGlzdGFuY2UgfTtcclxuICAgIH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./navmesh.ts\n");

/***/ }),

/***/ "./navpoly.ts":
/*!********************!*\
  !*** ./navpoly.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ NavPoly)\n/* harmony export */ });\n/* harmony import */ var _math_vector_2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math/vector-2 */ \"./math/vector-2.ts\");\n\r\n/**\r\n * A class that represents a navigable polygon with a navmesh. It is built on top of a\r\n * {@link Polygon}. It implements the properties and fields that javascript-astar needs - weight,\r\n * toString, isWall and getCost. See GPS test from astar repo for structure:\r\n * https://github.com/bgrins/javascript-astar/blob/master/test/tests.js\r\n */\r\nclass NavPoly {\r\n    /**\r\n     * Creates an instance of NavPoly.\r\n     */\r\n    constructor(id, polygon) {\r\n        // jsastar property:\r\n        this.weight = 1;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.id = id;\r\n        this.polygon = polygon;\r\n        this.edges = polygon.edges;\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n        this.centroid = this.calculateCentroid();\r\n        this.boundingRadius = this.calculateRadius();\r\n    }\r\n    /**\r\n     * Returns an array of points that form the polygon.\r\n     */\r\n    getPoints() {\r\n        return this.polygon.points;\r\n    }\r\n    /**\r\n     * Check if the given point-like object is within the polygon.\r\n     */\r\n    contains(point) {\r\n        // Phaser's polygon check doesn't handle when a point is on one of the edges of the line. Note:\r\n        // check numerical stability here. It would also be good to optimize this for different shapes.\r\n        return this.polygon.contains(point.x, point.y) || this.isPointOnEdge(point);\r\n    }\r\n    /**\r\n     * Only rectangles are supported, so this calculation works, but this is not actually the centroid\r\n     * calculation for a polygon. This is just the average of the vertices - proper centroid of a\r\n     * polygon factors in the area.\r\n     */\r\n    calculateCentroid() {\r\n        const centroid = new _math_vector_2__WEBPACK_IMPORTED_MODULE_0__.default(0, 0);\r\n        const length = this.polygon.points.length;\r\n        this.polygon.points.forEach((p) => centroid.add(p));\r\n        centroid.x /= length;\r\n        centroid.y /= length;\r\n        return centroid;\r\n    }\r\n    /**\r\n     * Calculate the radius of a circle that circumscribes the polygon.\r\n     */\r\n    calculateRadius() {\r\n        let boundingRadius = 0;\r\n        for (const point of this.polygon.points) {\r\n            const d = this.centroid.distance(point);\r\n            if (d > boundingRadius)\r\n                boundingRadius = d;\r\n        }\r\n        return boundingRadius;\r\n    }\r\n    /**\r\n     * Check if the given point-like object is on one of the edges of the polygon.\r\n     */\r\n    isPointOnEdge({ x, y }) {\r\n        for (const edge of this.edges) {\r\n            if (edge.pointOnSegment(x, y))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    destroy() {\r\n        this.neighbors = [];\r\n        this.portals = [];\r\n    }\r\n    // === jsastar methods ===\r\n    toString() {\r\n        return `NavPoly(id: ${this.id} at: ${this.centroid})`;\r\n    }\r\n    isWall() {\r\n        return this.weight === 0;\r\n    }\r\n    centroidDistance(navPolygon) {\r\n        return this.centroid.distance(navPolygon.centroid);\r\n    }\r\n    getCost(navPolygon) {\r\n        return this.centroidDistance(navPolygon);\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vbmF2cG9seS50cz9mYmQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbURBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVEsT0FBTyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9uYXZwb2x5LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZlY3RvcjIgZnJvbSBcIi4vbWF0aC92ZWN0b3ItMlwiO1xyXG4vKipcclxuICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBuYXZpZ2FibGUgcG9seWdvbiB3aXRoIGEgbmF2bWVzaC4gSXQgaXMgYnVpbHQgb24gdG9wIG9mIGFcclxuICoge0BsaW5rIFBvbHlnb259LiBJdCBpbXBsZW1lbnRzIHRoZSBwcm9wZXJ0aWVzIGFuZCBmaWVsZHMgdGhhdCBqYXZhc2NyaXB0LWFzdGFyIG5lZWRzIC0gd2VpZ2h0LFxyXG4gKiB0b1N0cmluZywgaXNXYWxsIGFuZCBnZXRDb3N0LiBTZWUgR1BTIHRlc3QgZnJvbSBhc3RhciByZXBvIGZvciBzdHJ1Y3R1cmU6XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iZ3JpbnMvamF2YXNjcmlwdC1hc3Rhci9ibG9iL21hc3Rlci90ZXN0L3Rlc3RzLmpzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZQb2x5IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBOYXZQb2x5LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgcG9seWdvbikge1xyXG4gICAgICAgIC8vIGpzYXN0YXIgcHJvcGVydHk6XHJcbiAgICAgICAgdGhpcy53ZWlnaHQgPSAxO1xyXG4gICAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgICAgdGhpcy55ID0gMDtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5wb2x5Z29uID0gcG9seWdvbjtcclxuICAgICAgICB0aGlzLmVkZ2VzID0gcG9seWdvbi5lZGdlcztcclxuICAgICAgICB0aGlzLm5laWdoYm9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMucG9ydGFscyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2VudHJvaWQgPSB0aGlzLmNhbGN1bGF0ZUNlbnRyb2lkKCk7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHRoaXMuY2FsY3VsYXRlUmFkaXVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcG9pbnRzIHRoYXQgZm9ybSB0aGUgcG9seWdvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0UG9pbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvbHlnb24ucG9pbnRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gcG9pbnQtbGlrZSBvYmplY3QgaXMgd2l0aGluIHRoZSBwb2x5Z29uLlxyXG4gICAgICovXHJcbiAgICBjb250YWlucyhwb2ludCkge1xyXG4gICAgICAgIC8vIFBoYXNlcidzIHBvbHlnb24gY2hlY2sgZG9lc24ndCBoYW5kbGUgd2hlbiBhIHBvaW50IGlzIG9uIG9uZSBvZiB0aGUgZWRnZXMgb2YgdGhlIGxpbmUuIE5vdGU6XHJcbiAgICAgICAgLy8gY2hlY2sgbnVtZXJpY2FsIHN0YWJpbGl0eSBoZXJlLiBJdCB3b3VsZCBhbHNvIGJlIGdvb2QgdG8gb3B0aW1pemUgdGhpcyBmb3IgZGlmZmVyZW50IHNoYXBlcy5cclxuICAgICAgICByZXR1cm4gdGhpcy5wb2x5Z29uLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpIHx8IHRoaXMuaXNQb2ludE9uRWRnZShwb2ludCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgcmVjdGFuZ2xlcyBhcmUgc3VwcG9ydGVkLCBzbyB0aGlzIGNhbGN1bGF0aW9uIHdvcmtzLCBidXQgdGhpcyBpcyBub3QgYWN0dWFsbHkgdGhlIGNlbnRyb2lkXHJcbiAgICAgKiBjYWxjdWxhdGlvbiBmb3IgYSBwb2x5Z29uLiBUaGlzIGlzIGp1c3QgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHZlcnRpY2VzIC0gcHJvcGVyIGNlbnRyb2lkIG9mIGFcclxuICAgICAqIHBvbHlnb24gZmFjdG9ycyBpbiB0aGUgYXJlYS5cclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlQ2VudHJvaWQoKSB7XHJcbiAgICAgICAgY29uc3QgY2VudHJvaWQgPSBuZXcgVmVjdG9yMigwLCAwKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnBvbHlnb24ucG9pbnRzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnBvbHlnb24ucG9pbnRzLmZvckVhY2goKHApID0+IGNlbnRyb2lkLmFkZChwKSk7XHJcbiAgICAgICAgY2VudHJvaWQueCAvPSBsZW5ndGg7XHJcbiAgICAgICAgY2VudHJvaWQueSAvPSBsZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIGNlbnRyb2lkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHJhZGl1cyBvZiBhIGNpcmNsZSB0aGF0IGNpcmN1bXNjcmliZXMgdGhlIHBvbHlnb24uXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVJhZGl1cygpIHtcclxuICAgICAgICBsZXQgYm91bmRpbmdSYWRpdXMgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdGhpcy5wb2x5Z29uLnBvaW50cykge1xyXG4gICAgICAgICAgICBjb25zdCBkID0gdGhpcy5jZW50cm9pZC5kaXN0YW5jZShwb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChkID4gYm91bmRpbmdSYWRpdXMpXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1JhZGl1cyA9IGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBib3VuZGluZ1JhZGl1cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHBvaW50LWxpa2Ugb2JqZWN0IGlzIG9uIG9uZSBvZiB0aGUgZWRnZXMgb2YgdGhlIHBvbHlnb24uXHJcbiAgICAgKi9cclxuICAgIGlzUG9pbnRPbkVkZ2UoeyB4LCB5IH0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy5lZGdlcykge1xyXG4gICAgICAgICAgICBpZiAoZWRnZS5wb2ludE9uU2VnbWVudCh4LCB5KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMubmVpZ2hib3JzID0gW107XHJcbiAgICAgICAgdGhpcy5wb3J0YWxzID0gW107XHJcbiAgICB9XHJcbiAgICAvLyA9PT0ganNhc3RhciBtZXRob2RzID09PVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGBOYXZQb2x5KGlkOiAke3RoaXMuaWR9IGF0OiAke3RoaXMuY2VudHJvaWR9KWA7XHJcbiAgICB9XHJcbiAgICBpc1dhbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0ID09PSAwO1xyXG4gICAgfVxyXG4gICAgY2VudHJvaWREaXN0YW5jZShuYXZQb2x5Z29uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudHJvaWQuZGlzdGFuY2UobmF2UG9seWdvbi5jZW50cm9pZCk7XHJcbiAgICB9XHJcbiAgICBnZXRDb3N0KG5hdlBvbHlnb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jZW50cm9pZERpc3RhbmNlKG5hdlBvbHlnb24pO1xyXG4gICAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./navpoly.ts\n");

/***/ }),

/***/ "./utils.ts":
/*!******************!*\
  !*** ./utils.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"distanceSquared\": () => (/* binding */ distanceSquared),\n/* harmony export */   \"projectPointToEdge\": () => (/* binding */ projectPointToEdge),\n/* harmony export */   \"triarea2\": () => (/* binding */ triarea2),\n/* harmony export */   \"clamp\": () => (/* binding */ clamp),\n/* harmony export */   \"almostEqual\": () => (/* binding */ almostEqual),\n/* harmony export */   \"angleDifference\": () => (/* binding */ angleDifference),\n/* harmony export */   \"areCollinear\": () => (/* binding */ areCollinear)\n/* harmony export */ });\n/* harmony import */ var _math_vector_2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math/vector-2 */ \"./math/vector-2.ts\");\n\r\n/**\r\n * Calculate the distance squared between two points. This is an optimization to a square root when\r\n * you just need to compare relative distances without needing to know the specific distance.\r\n * @param a\r\n * @param b\r\n */\r\nfunction distanceSquared(a, b) {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    return dx * dx + dy * dy;\r\n}\r\n/**\r\n * Project a point onto a line segment.\r\n * JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\r\n * @param point\r\n * @param line\r\n */\r\nfunction projectPointToEdge(point, line) {\r\n    const a = line.start;\r\n    const b = line.end;\r\n    // Consider the parametric equation for the edge's line, p = a + t (b - a). We want to find\r\n    // where our point lies on the line by solving for t:\r\n    //  t = [(p-a) . (b-a)] / |b-a|^2\r\n    const l2 = distanceSquared(a, b);\r\n    let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;\r\n    // We clamp t from [0,1] to handle points outside the segment vw.\r\n    t = clamp(t, 0, 1);\r\n    // Project onto the segment\r\n    const p = new _math_vector_2__WEBPACK_IMPORTED_MODULE_0__.default(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\r\n    return p;\r\n}\r\n/**\r\n * Twice the area of the triangle formed by a, b and c.\r\n */\r\nfunction triarea2(a, b, c) {\r\n    const ax = b.x - a.x;\r\n    const ay = b.y - a.y;\r\n    const bx = c.x - a.x;\r\n    const by = c.y - a.y;\r\n    return bx * ay - ax * by;\r\n}\r\n/**\r\n * Clamp the given value between min and max.\r\n */\r\nfunction clamp(value, min, max) {\r\n    if (value < min)\r\n        value = min;\r\n    if (value > max)\r\n        value = max;\r\n    return value;\r\n}\r\n/**\r\n * Check if two values are within a small margin of one another.\r\n */\r\nfunction almostEqual(value1, value2, errorMargin = 0.0001) {\r\n    if (Math.abs(value1 - value2) <= errorMargin)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n/**\r\n * Find the smallest angle difference between two angles\r\n * https://gist.github.com/Aaronduino/4068b058f8dbc34b4d3a9eedc8b2cbe0\r\n */\r\nfunction angleDifference(x, y) {\r\n    let a = x - y;\r\n    const i = a + Math.PI;\r\n    const j = Math.PI * 2;\r\n    a = i - Math.floor(i / j) * j; // (a+180) % 360; this ensures the correct sign\r\n    a -= Math.PI;\r\n    return a;\r\n}\r\n/**\r\n * Check if two lines are collinear (within a small error margin).\r\n */\r\nfunction areCollinear(line1, line2, errorMargin = 0.0001) {\r\n    // Figure out if the two lines are equal by looking at the area of the triangle formed\r\n    // by their points\r\n    const area1 = triarea2(line1.start, line1.end, line2.start);\r\n    const area2 = triarea2(line1.start, line1.end, line2.end);\r\n    if (almostEqual(area1, 0, errorMargin) && almostEqual(area2, 0, errorMargin)) {\r\n        return true;\r\n    }\r\n    else\r\n        return false;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9OYXZNZXNoLy4vdXRpbHMudHM/NTBmMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtREFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi91dGlscy50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWZWN0b3IyIGZyb20gXCIuL21hdGgvdmVjdG9yLTJcIjtcclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugc3F1YXJlZCBiZXR3ZWVuIHR3byBwb2ludHMuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvIGEgc3F1YXJlIHJvb3Qgd2hlblxyXG4gKiB5b3UganVzdCBuZWVkIHRvIGNvbXBhcmUgcmVsYXRpdmUgZGlzdGFuY2VzIHdpdGhvdXQgbmVlZGluZyB0byBrbm93IHRoZSBzcGVjaWZpYyBkaXN0YW5jZS5cclxuICogQHBhcmFtIGFcclxuICogQHBhcmFtIGJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZVNxdWFyZWQoYSwgYikge1xyXG4gICAgY29uc3QgZHggPSBiLnggLSBhLng7XHJcbiAgICBjb25zdCBkeSA9IGIueSAtIGEueTtcclxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxufVxyXG4vKipcclxuICogUHJvamVjdCBhIHBvaW50IG9udG8gYSBsaW5lIHNlZ21lbnQuXHJcbiAqIEpTIFNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDkyMTEvc2hvcnRlc3QtZGlzdGFuY2UtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxyXG4gKiBAcGFyYW0gcG9pbnRcclxuICogQHBhcmFtIGxpbmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0UG9pbnRUb0VkZ2UocG9pbnQsIGxpbmUpIHtcclxuICAgIGNvbnN0IGEgPSBsaW5lLnN0YXJ0O1xyXG4gICAgY29uc3QgYiA9IGxpbmUuZW5kO1xyXG4gICAgLy8gQ29uc2lkZXIgdGhlIHBhcmFtZXRyaWMgZXF1YXRpb24gZm9yIHRoZSBlZGdlJ3MgbGluZSwgcCA9IGEgKyB0IChiIC0gYSkuIFdlIHdhbnQgdG8gZmluZFxyXG4gICAgLy8gd2hlcmUgb3VyIHBvaW50IGxpZXMgb24gdGhlIGxpbmUgYnkgc29sdmluZyBmb3IgdDpcclxuICAgIC8vICB0ID0gWyhwLWEpIC4gKGItYSldIC8gfGItYXxeMlxyXG4gICAgY29uc3QgbDIgPSBkaXN0YW5jZVNxdWFyZWQoYSwgYik7XHJcbiAgICBsZXQgdCA9ICgocG9pbnQueCAtIGEueCkgKiAoYi54IC0gYS54KSArIChwb2ludC55IC0gYS55KSAqIChiLnkgLSBhLnkpKSAvIGwyO1xyXG4gICAgLy8gV2UgY2xhbXAgdCBmcm9tIFswLDFdIHRvIGhhbmRsZSBwb2ludHMgb3V0c2lkZSB0aGUgc2VnbWVudCB2dy5cclxuICAgIHQgPSBjbGFtcCh0LCAwLCAxKTtcclxuICAgIC8vIFByb2plY3Qgb250byB0aGUgc2VnbWVudFxyXG4gICAgY29uc3QgcCA9IG5ldyBWZWN0b3IyKGEueCArIHQgKiAoYi54IC0gYS54KSwgYS55ICsgdCAqIChiLnkgLSBhLnkpKTtcclxuICAgIHJldHVybiBwO1xyXG59XHJcbi8qKlxyXG4gKiBUd2ljZSB0aGUgYXJlYSBvZiB0aGUgdHJpYW5nbGUgZm9ybWVkIGJ5IGEsIGIgYW5kIGMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJpYXJlYTIoYSwgYiwgYykge1xyXG4gICAgY29uc3QgYXggPSBiLnggLSBhLng7XHJcbiAgICBjb25zdCBheSA9IGIueSAtIGEueTtcclxuICAgIGNvbnN0IGJ4ID0gYy54IC0gYS54O1xyXG4gICAgY29uc3QgYnkgPSBjLnkgLSBhLnk7XHJcbiAgICByZXR1cm4gYnggKiBheSAtIGF4ICogYnk7XHJcbn1cclxuLyoqXHJcbiAqIENsYW1wIHRoZSBnaXZlbiB2YWx1ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xyXG4gICAgaWYgKHZhbHVlIDwgbWluKVxyXG4gICAgICAgIHZhbHVlID0gbWluO1xyXG4gICAgaWYgKHZhbHVlID4gbWF4KVxyXG4gICAgICAgIHZhbHVlID0gbWF4O1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSB3aXRoaW4gYSBzbWFsbCBtYXJnaW4gb2Ygb25lIGFub3RoZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWxtb3N0RXF1YWwodmFsdWUxLCB2YWx1ZTIsIGVycm9yTWFyZ2luID0gMC4wMDAxKSB7XHJcbiAgICBpZiAoTWF0aC5hYnModmFsdWUxIC0gdmFsdWUyKSA8PSBlcnJvck1hcmdpbilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmQgdGhlIHNtYWxsZXN0IGFuZ2xlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gYW5nbGVzXHJcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0Fhcm9uZHVpbm8vNDA2OGIwNThmOGRiYzM0YjRkM2E5ZWVkYzhiMmNiZTBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhbmdsZURpZmZlcmVuY2UoeCwgeSkge1xyXG4gICAgbGV0IGEgPSB4IC0geTtcclxuICAgIGNvbnN0IGkgPSBhICsgTWF0aC5QSTtcclxuICAgIGNvbnN0IGogPSBNYXRoLlBJICogMjtcclxuICAgIGEgPSBpIC0gTWF0aC5mbG9vcihpIC8gaikgKiBqOyAvLyAoYSsxODApICUgMzYwOyB0aGlzIGVuc3VyZXMgdGhlIGNvcnJlY3Qgc2lnblxyXG4gICAgYSAtPSBNYXRoLlBJO1xyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byBsaW5lcyBhcmUgY29sbGluZWFyICh3aXRoaW4gYSBzbWFsbCBlcnJvciBtYXJnaW4pLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUNvbGxpbmVhcihsaW5lMSwgbGluZTIsIGVycm9yTWFyZ2luID0gMC4wMDAxKSB7XHJcbiAgICAvLyBGaWd1cmUgb3V0IGlmIHRoZSB0d28gbGluZXMgYXJlIGVxdWFsIGJ5IGxvb2tpbmcgYXQgdGhlIGFyZWEgb2YgdGhlIHRyaWFuZ2xlIGZvcm1lZFxyXG4gICAgLy8gYnkgdGhlaXIgcG9pbnRzXHJcbiAgICBjb25zdCBhcmVhMSA9IHRyaWFyZWEyKGxpbmUxLnN0YXJ0LCBsaW5lMS5lbmQsIGxpbmUyLnN0YXJ0KTtcclxuICAgIGNvbnN0IGFyZWEyID0gdHJpYXJlYTIobGluZTEuc3RhcnQsIGxpbmUxLmVuZCwgbGluZTIuZW5kKTtcclxuICAgIGlmIChhbG1vc3RFcXVhbChhcmVhMSwgMCwgZXJyb3JNYXJnaW4pICYmIGFsbW9zdEVxdWFsKGFyZWEyLCAwLCBlcnJvck1hcmdpbikpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./index.ts");
/******/ })()
.default;
});