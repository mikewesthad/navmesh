<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="./">
  <title data-ice="title">Manual</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-injected-style.css"></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/README.html"><a href="manual/README.html" data-ice="link">Navigation Meshes Overview </a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#introduction" data-ice="link">Introduction</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#installation" data-ice="link">Installation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/README.html"><a href="manual/README.html#as-a-script" data-ice="link">As a Script</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/README.html"><a href="manual/README.html#as-a-module" data-ice="link">As a Module</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#creating-a-navigation-mesh" data-ice="link">Creating a Navigation Mesh</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#usage" data-ice="link">Usage</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/README.html"><a href="manual/README.html#navmesh" data-ice="link">navmesh</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/README.html"><a href="manual/README.html#phaser-navmesh" data-ice="link">phaser-navmesh</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/README.html"><a href="manual/README.html#phaser2-navmesh" data-ice="link">phaser2-navmesh</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#performance-comparison" data-ice="link">Performance Comparison</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#development" data-ice="link">Development</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#changelogs" data-ice="link">Changelogs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#references" data-ice="link">References</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/README.html"><a href="manual/README.html#to-dos" data-ice="link">To Dos</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/tiled-navmesh-guide.html"><a href="manual/tiled-navmesh-guide.html" data-ice="link">Creating a NavMesh in Tiled</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tiled-navmesh-guide.html"><a href="manual/tiled-navmesh-guide.html#goal" data-ice="link">Goal</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tiled-navmesh-guide.html"><a href="manual/tiled-navmesh-guide.html#snapping-setup" data-ice="link">Snapping Setup</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tiled-navmesh-guide.html"><a href="manual/tiled-navmesh-guide.html#creating-the-mesh" data-ice="link">Creating the Mesh</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tiled-navmesh-guide.html"><a href="manual/tiled-navmesh-guide.html#agent-size--gaps-" data-ice="link">Agent Size (Gaps)</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  <div class="manual-user-index" data-ice="manualUserIndex"><h1 id="navigation-meshes-overview------omit-in-toc----">Navigation Meshes Overview <!-- omit in toc --></h1><p>A JS plugin for fast pathfinding using <a href="https://en.wikipedia.org/wiki/Navigation_mesh">navigation meshes</a>, with optional wrappers for the Phaser v2 and Phaser v3 game engines.</p>
<p><a href="https://www.mikewesthad.com/navmesh/demo/"><img src="./doc-source/single-following-agent.gif" width="400"></a></p>
<p><a href="https://www.mikewesthad.com/navmesh/demo/">Interactive demo</a></p>
<p>(Note: if you are viewing this on GitHub or NPM, you might want to check out the HTML documentation <a href="https://www.mikewesthad.com/navmesh/docs/">here</a>.)</p>
<p>Table of Contents:</p>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#as-a-script">As a Script</a></li>
<li><a href="#as-a-module">As a Module</a></li>
</ul>
</li>
<li><a href="#creating-a-navigation-mesh">Creating a Navigation Mesh</a></li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#navmesh">navmesh</a></li>
<li><a href="#phaser-navmesh">phaser-navmesh</a></li>
<li><a href="#phaser2-navmesh">phaser2-navmesh</a></li>
</ul>
</li>
<li><a href="#performance-comparison">Performance Comparison</a></li>
<li><a href="#development">Development</a></li>
<li><a href="#changelogs">Changelogs</a></li>
<li><a href="#references">References</a></li>
<li><a href="#to-dos">To Dos</a></li>
</ul>
<h2 id="introduction">Introduction</h2><p>Pathfinding is essentially the problem of solving a maze, finding a path between points while avoiding obstacles. When pathfinding in games, we need to:</p>
<ol>
<li>Represent the game world in a way that defines what areas are walkable.</li>
<li>Search that representation for the shortest path.</li>
</ol>
<p>When it comes to 2D pathfinding, a common approach is to represent the world using <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/Tilemaps">tiles</a> (a grid) and then search for a path using the <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* algorithm</a> ((e.g. <a href="https://github.com/photonstorm/phaser-plugins/tree/master/AStar">Phaser AStar</a>). If you have a 50 x 50 tile world, searching for a path involves searching through a representation of the world with up to 2500 locations (&quot;nodes&quot;).</p>
<p>This plugin uses navigation meshes to simplify that search. Instead of representing the world as a grid of tiles, it represents the walkable areas of the world as a mesh. That means that the representation of the world has far fewer nodes, and hence, can be searched much faster than the grid approach. This approach is 5x - 150x faster than Phaser&apos;s A* plugin (see performance section), depending on the mesh.</p>
<p>The example map below (left) is a 30 x 30 map. As a grid, there are 900 nodes, but as a navmesh (right) there are 27 nodes (colored rectangles).</p>
<p><img src="./doc-source/combined.png" width="700"></p>
<h2 id="installation">Installation</h2><p>This repository contains 3 related JS packages:</p>
<ul>
<li><code>navmesh</code> - core logic, game-engine agnostic, usable outside of Phaser.</li>
<li><code>phaser-navmesh</code> - Phaser v3 wrapper around <code>navmesh</code> that creates a Phaser 3 Scene plugin. Phaser 3 is expected to be a dependency in your project.</li>
<li><code>phaser2-navmesh</code> - Phaser v2 wrapper around <code>navmesh</code> that creates a Phaser 2 game plugin. Phaser 2 or Phaser-ce is expected to be in the global scope.</li>
</ul>
<p>You can use any of them as a script or as a module in your bundler of choice.</p>
<h3 id="as-a-script">As a Script</h3><p>You can drop in any of the transpiled code into your project as a standalone script. Download the version that you want:</p>
<table>
<thead>
<tr>
<th>navmesh</th>
<th>phaser-navmesh</th>
<th>phaser2-navmesh</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/navmesh/dist/navmesh.min.js">minified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/navmesh/dist/navmesh.min.js.map">map</a></td>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser-navmesh/dist/phaser-navmesh.min.js">minified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser-navmesh/dist/phaser-navmesh.min.js.map">map</a></td>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser2-navmesh/dist/phaser2-navmesh.min.js">minified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser2-navmesh/dist/phaser2-navmesh.min.js.map">map</a></td>
</tr>
<tr>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/navmesh/dist/navmesh.js">unminified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/navmesh/dist/navmesh.js.map">map</a></td>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser-navmesh/dist/phaser-navmesh.js">unminified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser-navmesh/dist/phaser-navmesh.js.map">map</a></td>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser2-navmesh/dist/phaser2-navmesh.js">unminified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser2-navmesh/dist/phaser2-navmesh.js.map">map</a></td>
</tr>
<tr>
<td>Library Name: NavMesh</td>
<td>Library Name: PhaserNavMeshPlugin</td>
<td>Library Name: Phaser2NavMeshPlugin</td>
</tr>
</tbody>
</table>
<p>E.g. if you wanted phaser-navmesh, you would add this to your HTML:</p>
<pre><code class="lang-html"><code class="source-code prettyprint">&lt;script src=&quot;phaser-navmesh.min.js&quot;&gt;&lt;/script&gt;</code>
</code></pre>
<p>Inside of your own script, you can now use the global variable <code>PhaserNavMeshPlugin</code> (see library name in the above table), e.g.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">const game = new Phaser.Game({
  type: Phaser.AUTO,
  width: 750,
  height: 750,
  plugins: {
    scene: [
      { key: &quot;NavMeshPlugin&quot;, plugin: PhaserNavMeshPlugin, mapping: &quot;navMeshPlugin&quot;, start: true }
    ]
  }
});</code>
</code></pre>
<p>See <a href="#usage">usage</a> for more information on how to use each of the three modules in this repository.</p>
<h3 id="as-a-module">As a Module</h3><p>Install the appropriate dependency:</p>
<ul>
<li><code>npm install --save navmesh</code> for usage outside of Phaser</li>
<li><code>npm install --save phaser-navmesh</code> for Phaser 3</li>
<li><code>npm install --save phaser2-navmesh</code> for Phaser 2</li>
</ul>
<p>To use the transpiled and minified distribution of the library:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import PhaserNavMeshPlugin from &quot;phaser-navmesh&quot;;</code>
</code></pre>
<p>To use the raw library (so you can transpile it to match your own project settings):</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import PhaserNavMeshPlugin from &quot;phaser-navmesh/src&quot;;</code>
</code></pre>
<h2 id="creating-a-navigation-mesh">Creating a Navigation Mesh</h2><p>Before you can dive into the code, you&apos;ll need to create a navigation mesh for your game world. This is a process of defining the walkable areas within you world. You can create it from scratch in code, but it&apos;s far easier to use a tilemap editor like Tiled to do this. See <a href="https://www.mikewesthad.com/navmesh/docs/manual/tiled-navmesh-guide.html">guide</a>.</p>
<p>Note: the current version of the library only supports <a href="https://www.sparknotes.com/math/geometry1/polygons/section2/">convex polygons</a>.
There are libraries like <a href="https://github.com/schteppe/poly-decomp.js/">poly-decom.js</a> for decomposing a concave polygon into easier to manage convex polygons. It&apos;s on the to do list to handle any polygon, but I&apos;ve found that automatically decomposing polygons leads to worse performance than hand-mapping the levels with convex polygons.</p>
<h2 id="usage">Usage</h2><h3 id="navmesh">navmesh</h3><p>If you don&apos;t need the Phaser wrappers, you can construct navmeshes directly from points using the navmesh package:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import NavMesh from &quot;navmesh&quot;;

/*
  Imaging your game world has three walkable rooms, like this:

    +-----+-----+
    |     |     |
    |  1  |  2  |
    |     |     |
    +-----------+
          |     |
          |  3  |
          |     |
          +-----+
*/

// The mesh is represented as an array where each element contains the points for an indivdual
// polygon within the mesh.
const meshPolygonPoints = [
  [{ x: 0, y: 0 }, { x: 10, y: 0 }, { x: 10, y: 10 }, { x: 0, y: 10 }], // Polygon 1
  [{ x: 10, y: 0 }, { x: 20, y: 0 }, { x: 20, y: 10 }, { x: 10, y: 10 }], // Polygon 2
  [{ x: 10, y: 0 }, { x: 20, y: 10 }, { x: 20, y: 20 }, { x: 10, y: 20 }] // Polygon 3
];
const navMesh = new NavMesh(meshPolygonPoints);

// Find a path from the top left of room 1 to the bottom left of room 3
const path = navMesh.findPath({ x: 0, y: 0 }, { x: 10, y: 20 });
// &#x2BA1;  [{ x: 0, y: 0 }, { x: 10, y: 10 }, { x: 10, y: 20 }]</code>
</code></pre>
<p>Check out the <a href="https://www.mikewesthad.com/navmesh/docs/identifiers.html#navmesh-src">API reference</a> for more information.</p>
<h3 id="phaser-navmesh">phaser-navmesh</h3><p>If you are working with Phaser 3, you can use the phaser-navmesh package, which provides a Scene plugin. See this <a href="https://github.com/mikewesthad/navmesh/tree/master/packages/examples/src">example</a> for more complete usage.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import Phaser from &quot;phaser&quot;;
import PhaserNavMeshPlugin from &quot;phaser-navmesh&quot;;

const game = new Phaser.Game({
  type: Phaser.AUTO,
  parent: &quot;game-container&quot;,
  width: 750,
  height: 750,
  plugins: {
    scene: [
      {
        key: &quot;PhaserNavMeshPlugin&quot;, // Key to store the plugin class under in cache
        plugin: PhaserNavMeshPlugin, // Class that constructs plugins
        mapping: &quot;navMeshPlugin&quot;, // Property mapping to use for the scene, e.g. this.navMeshPlugin
        start: true
      }
    ]
  },
  scene: {
    preload: preload,
    create: create
  }
});

function preload() {
  this.load.tilemapTiledJSON(&quot;map&quot;, &quot;tilemaps/map.json&quot;);
  this.load.image(&quot;tiles&quot;, &quot;tilemaps/tiles.png&quot;);
}

function create() {
  // Set up a tilemap with at least one layer
  const tilemap = this.add.tilemap(&quot;map&quot;);
  const tileset = tilemap.addTilesetImage(&quot;tiles&quot;, &quot;tiles&quot;);
  const wallLayer = tilemap.createStaticLayer(&quot;walls&quot;, tileset);

  // Load the navMesh from the tilemap object layer &quot;navmesh&quot; (created in Tiled). The navMesh was
  // created with 12.5 pixels of space around obstacles.
  const objectLayer = tilemap.getObjectLayer(&quot;navmesh&quot;);
  const navMesh = this.navMeshPlugin.buildMeshFromTiled(&quot;mesh&quot;, objectLayer, 12.5);
  const path = navMesh.findPath({ x: 0, y: 0 }, { x: 300, y: 400 });
  // &#x2BA1;  path will either be null or an array of Phaser.Geom.Point objects
}</code>
</code></pre>
<p>The plugin comes with some methods for visually debugging your navmesh:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">navMesh.enableDebug(); // Creates a Phaser.Graphics overlay on top of the screen
navMesh.debugDrawClear(); // Clears the overlay
// Visualize the underlying navmesh
navMesh.debugDrawMesh({
  drawCentroid: true,
  drawBounds: false,
  drawNeighbors: true,
  drawPortals: true
});
// Visualize an individual path
navMesh.debugDrawPath(path, 0xffd900);</code>
</code></pre>
<p>Check out the <a href="https://www.mikewesthad.com/navmesh/docs/identifiers.html#phaser-navmesh-src">API reference</a> for more information.</p>
<h3 id="phaser2-navmesh">phaser2-navmesh</h3><p>If you are working with Phaser 2, you can use the phaser2-navmesh package, which provides a game plugin. See this <a href="https://github.com/mikewesthad/navmesh/tree/master/packages/examples-phaser2/src">example</a> for more complete usage. You can also look at the <a href="#phaser-navmesh">previous section</a> for Phaser usage.</p>
<h2 id="performance-comparison">Performance Comparison</h2><p><em>(Note: these comparisons were done in any earlier verison of the repo before Phaser v3 was released. The plugins tested haven&apos;t been released in v3 versions yet, so this section could use an update. That said, the results should be the same.)</em></p>
<p>Comparing this navmesh plugin against:</p>
<ul>
<li><a href="https://github.com/photonstorm/phaser-plugins">Phaser&apos;s grid-based A* plugin</a>. Navmesh is approximately 5x - 150x faster.</li>
<li>A faster, grid-based A* search, <a href="https://github.com/prettymuchbryce/easystarjs">EasyStar.js</a>. Navmesh is approximately 5x - 20x faster.</li>
</ul>
<p>Performance depends on the size of the area that needs to be searched. Finding for a path between points that are 50 pixels away is (generally) going to be much faster than finding a path between points that are 5000 pixels away.</p>
<p>Details (see <a href="https://github.com/mikewesthad/navmesh/tree/master/src/examples/performance">src/library/performance</a>):</p>
<pre><code><code class="source-code prettyprint">Performance Comparison, 100000 iterations, 30x30 tilemap

Short paths (150 - 500 pixel length)

    Average time per iteration:
        AStart Plugin: 0.02470ms
        EasyStar Plugin: 0.02876ms
        NavMesh Plugin: 0.00575ms

    Comparison:
        NavMesh is 4.30x faster than Phaser AStar
        NavMesh is 5.00x faster than EasyStar

Long paths (600 pixels and greater length), average time per iteration:

    Average time per iteration:
        AStart Plugin: 1.38710ms
        EasyStar Plugin: 0.15977ms
        NavMesh Plugin: 0.00738ms

    Comparison:
        NavMesh is 187.95x faster than Phaser AStar
        NavMesh is 21.65x faster than EasyStar</code>
</code></pre><h2 id="development">Development</h2><p>Pull requests are welcome (see <a href="#to-dos">todos</a>)! If you want to run this repo locally, make sure you have <a href="https://nodejs.org/en/">node</a> installed. Download the repo, open a terminal in the repo folder and run:</p>
<pre><code><code class="source-code prettyprint">npm install
npm run bootstrap</code>
</code></pre><p>This project uses <a href="https://github.com/lerna/lerna">lerna</a> and <a href="https://yarnpkg.com/lang/en/docs/workspaces/">yarn workspaces</a> to manage multiple packages within one repository. <code>npm install</code> will pull the root dependencies and <code>npm run bootstrap</code> will use lerna &amp; yarn to pull and link dependencies within &quot;packages/&quot;. This project has the following packages:</p>
<ul>
<li><code>navmesh</code> - core logic, game-engine agnostic</li>
<li><code>phaser-navmesh</code> - Phaser Plugin v3 wrapper around <code>navmesh</code></li>
<li><code>phaser2-navmesh</code> - Phaser Plugin v2 wrapper around <code>navmesh</code></li>
</ul>
<p>The project is controlled via npm scripts. The main ones to use:</p>
<ul>
<li><code>npm run build</code> - will build all the individual packages within &quot;packages/&quot;.</li>
<li><code>npm run dev</code> - watch &amp; serve the examples. A browser window will pop up with links to the examples. If you are working on the library, this is the easiest way to do &quot;functional testing&quot; by using the library in a game environment.</li>
<li><code>npm run test</code> - will run the automated tests against the library.</li>
</ul>
<h2 id="changelogs">Changelogs</h2><ul>
<li><a href="https://github.com/mikewesthad/navmesh/blob/master/packages/phaser-navmesh/README.md">Phaser NavMesh (for Phaser v3)</a></li>
<li><a href="https://github.com/mikewesthad/navmesh/blob/master/packages/phaser2-navmesh/README.md">Phaser 2 NavMesh</a></li>
<li><a href="https://github.com/mikewesthad/navmesh/blob/master/packages/navmesh/README.md">NavMesh</a></li>
</ul>
<h2 id="references">References</h2><p>Helpful resources used while building this plugin:</p>
<ul>
<li>Inspired by <a href="https://github.com/nickjanssen/PatrolJS">PatrolJS</a>, an implementation of navmeshes for threejs</li>
<li>Navmesh path-finding algorithm explanations:<ul>
<li><a href="http://jceipek.com/Olin-Coding-Tutorials/pathing.html">Game Path Planning by Julian Ceipek</a></li>
<li><a href="http://digestingduck.blogspot.com/2010/03/simple-stupid-funnel-algorithm.html">Simple Stupid Funnel Algorithm</a></li>
</ul>
</li>
<li><a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">Advice on astar heuristics</a></li>
</ul>
<h2 id="to-dos">To Dos</h2><ul>
<li>Features<ul>
<li>Allow non-square navmesh polygons from Tiled - ideally, any convex shape.</li>
<li>Reimplement the autotessalation version of the lib &amp; try libtess in quad mode.</li>
<li>The astar heuristic &amp; cost functions need another pass. They don&apos;t always produce the shortest path. Implement incomplete funneling while building the astar path?</li>
<li>The navmesh assumes any polygon can reach any other polygon. This probably should be extended to put connected polygons into groups like patroljs.</li>
<li>Better warnings for devs - warn on empty map, warn on disconnected map, warn if polygons are malformed.</li>
<li>Factor in the layer position / scale / rotation</li>
</ul>
</li>
<li>Testing<ul>
<li>Check against tilemap that is larger than the screen</li>
</ul>
</li>
<li>Research<ul>
<li>There are probably optimization tricks to do when dealing with certain types of shapes. E.g. we are using axis-aligned boxes for the polygons and it is dead simple to calculate if a point is inside one of those...</li>
<li>Investigate <a href="http://www.david-gouveia.com/portfolio/pathfinding-on-a-2d-polygonal-map/">Points-of-Visibility</a> pathfinding to compare speed</li>
</ul>
</li>
</ul>
</div>

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Navigation Meshes Overview </h1><p>A JS plugin for fast pathfinding using <a href="https://en.wikipedia.org/wiki/Navigation_mesh">navigation meshes</a>, with optional wrappers for the Phaser v2 and Phaser v3 game engines.</p><p><a href="https://www.mikewesthad.com/navmesh/demo/"><img src="./manual/./doc-source/single-following-agent.gif" width="400"></a></p><p><a href="https://www.mikewesthad.com/navmesh/demo/">Interactive demo</a></p><p>(Note: if you are viewing this on GitHub or NPM, you might want to check out the HTML documentation <a href="https://www.mikewesthad.com/navmesh/docs/">here</a>.)</p><p>Table of Contents:</p><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#as-a-script">As a Script</a></li>
<li><a href="#as-a-module">As a Module</a></li>
</ul>
</li>
<li><a href="#creating-a-navigation-mesh">Creating a Navigation Mesh</a></li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#navmesh">navmesh</a></li>
<li><a href="#phaser-navmesh">phaser-navmesh</a></li>
<li><a href="#phaser2-navmesh">phaser2-navmesh</a></li>
</ul>
</li>
<li><a href="#performance-comparison">Performance Comparison</a></li>
<li><a href="#development">Development</a></li>
<li><a href="#changelogs">Changelogs</a></li>
<li><a href="#references">References</a></li>
<li><a href="#to-dos">To Dos</a></li>
</ul><h2>Introduction</h2><p>Pathfinding is essentially the problem of solving a maze, finding a path between points while avoiding obstacles. When pathfinding in games, we need to:</p><ol>
<li>Represent the game world in a way that defines what areas are walkable.</li>
<li>Search that representation for the shortest path.</li>
</ol><p>When it comes to 2D pathfinding, a common approach is to represent the world using <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/Tilemaps">tiles</a> (a grid) and then search for a path using the <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* algorithm</a> ((e.g. <a href="https://github.com/photonstorm/phaser-plugins/tree/master/AStar">Phaser AStar</a>). If you have a 50 x 50 tile world, searching for a path involves searching through a representation of the world with up to 2500 locations (&quot;nodes&quot;).</p><p>This plugin uses navigation meshes to simplify that search. Instead of representing the world as a grid of tiles, it represents the walkable areas of the world as a mesh. That means that the representation of the world has far fewer nodes, and hence, can be searched much faster than the grid approach. This approach is 5x - 150x faster than Phaser&apos;s A* plugin (see performance section), depending on the mesh.</p><p>The example map below (left) is a 30 x 30 map. As a grid, there are 900 nodes, but as a navmesh (right) there are 27 nodes (colored rectangles).</p><p><img src="./manual/./doc-source/combined.png" width="700"></p><h2>Installation</h2><p>This repository contains 3 related JS packages:</p><ul>
<li><code>navmesh</code> - core logic, game-engine agnostic, usable outside of Phaser.</li>
<li><code>phaser-navmesh</code> - Phaser v3 wrapper around <code>navmesh</code> that creates a Phaser 3 Scene plugin. Phaser 3 is expected to be a dependency in your project.</li>
<li><code>phaser2-navmesh</code> - Phaser v2 wrapper around <code>navmesh</code> that creates a Phaser 2 game plugin. Phaser 2 or Phaser-ce is expected to be in the global scope.</li>
</ul><p>You can use any of them as a script or as a module in your bundler of choice.</p><h3>As a Script</h3><p>You can drop in any of the transpiled code into your project as a standalone script. Download the version that you want:</p><table>
<thead>
<tr>
<th>navmesh</th>
<th>phaser-navmesh</th>
<th>phaser2-navmesh</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/navmesh/dist/navmesh.min.js">minified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/navmesh/dist/navmesh.min.js.map">map</a></td>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser-navmesh/dist/phaser-navmesh.min.js">minified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser-navmesh/dist/phaser-navmesh.min.js.map">map</a></td>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser2-navmesh/dist/phaser2-navmesh.min.js">minified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser2-navmesh/dist/phaser2-navmesh.min.js.map">map</a></td>
</tr>
<tr>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/navmesh/dist/navmesh.js">unminified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/navmesh/dist/navmesh.js.map">map</a></td>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser-navmesh/dist/phaser-navmesh.js">unminified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser-navmesh/dist/phaser-navmesh.js.map">map</a></td>
<td><a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser2-navmesh/dist/phaser2-navmesh.js">unminified</a> &amp; source <a href="https://raw.githubusercontent.com/mikewesthad/navmesh/master/packages/phaser2-navmesh/dist/phaser2-navmesh.js.map">map</a></td>
</tr>
<tr>
<td>Library Name: NavMesh</td>
<td>Library Name: PhaserNavMeshPlugin</td>
<td>Library Name: Phaser2NavMeshPlugin</td>
</tr>
</tbody>
</table><p>E.g. if you wanted phaser-navmesh, you would add this to your HTML:</p><pre><code class="lang-html"><code class="source-code prettyprint">&lt;script src=&quot;phaser-navmesh.min.js&quot;&gt;&lt;/script&gt;</code>
</code></pre><p>Inside of your own script, you can now use the global variable <code>PhaserNavMeshPlugin</code> (see library name in the above table), e.g.</p><pre><code class="lang-js"><code class="source-code prettyprint">const game = new Phaser.Game({
  type: Phaser.AUTO,
  width: 750,
  height: 750,
  plugins: {
    scene: [
      { key: &quot;NavMeshPlugin&quot;, plugin: PhaserNavMeshPlugin, mapping: &quot;navMeshPlugin&quot;, start: true }
    ]
  }
});</code>
</code></pre><p>See <a href="#usage">usage</a> for more information on how to use each of the three modules in this repository.</p><h3>As a Module</h3><p>Install the appropriate dependency:</p><ul>
<li><code>npm install --save navmesh</code> for usage outside of Phaser</li>
<li><code>npm install --save phaser-navmesh</code> for Phaser 3</li>
<li><code>npm install --save phaser2-navmesh</code> for Phaser 2</li>
</ul><p>To use the transpiled and minified distribution of the library:</p><pre><code class="lang-js"><code class="source-code prettyprint">import PhaserNavMeshPlugin from &quot;phaser-navmesh&quot;;</code>
</code></pre><p>To use the raw library (so you can transpile it to match your own project settings):</p><pre><code class="lang-js"><code class="source-code prettyprint">import PhaserNavMeshPlugin from &quot;phaser-navmesh/src&quot;;</code>
</code></pre><h2>Creating a Navigation Mesh</h2><p>Before you can dive into the code, you&apos;ll need to create a navigation mesh for your game world. This is a process of defining the walkable areas within you world. You can create it from scratch in code, but it&apos;s far easier to use a tilemap editor like Tiled to do this. See <a href="https://www.mikewesthad.com/navmesh/docs/manual/tiled-navmesh-guide.html">guide</a>.</p><p>Note: the current version of the library only supports <a href="https://www.sparknotes.com/math/geometry1/polygons/section2/">convex polygons</a>.
There are libraries like <a href="https://github.com/schteppe/poly-decomp.js/">poly-decom.js</a> for decomposing a concave polygon into easier to manage convex polygons. It&apos;s on the to do list to handle any polygon, but I&apos;ve found that automatically decomposing polygons leads to worse performance than hand-mapping the levels with convex polygons.</p><h2>Usage</h2><h3>navmesh</h3><p>If you don&apos;t need the Phaser wrappers, you can construct navmeshes directly from points using the navmesh package:</p><pre><code class="lang-js"><code class="source-code prettyprint">import NavMesh from &quot;navmesh&quot;;

/*
  Imaging your game world has three walkable rooms, like this:

    +-----+-----+
    |     |     |
    |  1  |  2  |
    |     |     |
    +-----------+
          |     |
          |  3  |
          |     |
          +-----+
*/

// The mesh is represented as an array where each element contains the points for an indivdual
// polygon within the mesh.
const meshPolygonPoints = [
  [{ x: 0, y: 0 }, { x: 10, y: 0 }, { x: 10, y: 10 }, { x: 0, y: 10 }], // Polygon 1
  [{ x: 10, y: 0 }, { x: 20, y: 0 }, { x: 20, y: 10 }, { x: 10, y: 10 }], // Polygon 2
  [{ x: 10, y: 0 }, { x: 20, y: 10 }, { x: 20, y: 20 }, { x: 10, y: 20 }] // Polygon 3
];
const navMesh = new NavMesh(meshPolygonPoints);

// Find a path from the top left of room 1 to the bottom left of room 3
const path = navMesh.findPath({ x: 0, y: 0 }, { x: 10, y: 20 });
// &#x2BA1;  [{ x: 0, y: 0 }, { x: 10, y: 10 }, { x: 10, y: 20 }]</code>
</code></pre><p>Check out the <a href="https://www.mikewesthad.com/navmesh/docs/identifiers.html#navmesh-src">API reference</a> for more information.</p><h3>phaser-navmesh</h3><p>If you are working with Phaser 3, you can use the phaser-navmesh package, which provides a Scene plugin. See this <a href="https://github.com/mikewesthad/navmesh/tree/master/packages/examples/src">example</a> for more complete usage.</p><pre><code class="lang-js"><code class="source-code prettyprint">import Phaser from &quot;phaser&quot;;
import PhaserNavMeshPlugin from &quot;phaser-navmesh&quot;;

const game = new Phaser.Game({
  type: Phaser.AUTO,
  parent: &quot;game-container&quot;,
  width: 750,
  height: 750,
  plugins: {
    scene: [
      {
        key: &quot;PhaserNavMeshPlugin&quot;, // Key to store the plugin class under in cache
        plugin: PhaserNavMeshPlugin, // Class that constructs plugins
        mapping: &quot;navMeshPlugin&quot;, // Property mapping to use for the scene, e.g. this.navMeshPlugin
        start: true
      }
    ]
  },
  scene: {
    preload: preload,
    create: create
  }
});

function preload() {
  this.load.tilemapTiledJSON(&quot;map&quot;, &quot;tilemaps/map.json&quot;);
  this.load.image(&quot;tiles&quot;, &quot;tilemaps/tiles.png&quot;);
}

function create() {
  // Set up a tilemap with at least one layer
  const tilemap = this.add.tilemap(&quot;map&quot;);
  const tileset = tilemap.addTilesetImage(&quot;tiles&quot;, &quot;tiles&quot;);
  const wallLayer = tilemap.createStaticLayer(&quot;walls&quot;, tileset);

  // Load the navMesh from the tilemap object layer &quot;navmesh&quot; (created in Tiled). The navMesh was
  // created with 12.5 pixels of space around obstacles.
  const objectLayer = tilemap.getObjectLayer(&quot;navmesh&quot;);
  const navMesh = this.navMeshPlugin.buildMeshFromTiled(&quot;mesh&quot;, objectLayer, 12.5);
  const path = navMesh.findPath({ x: 0, y: 0 }, { x: 300, y: 400 });
  // &#x2BA1;  path will either be null or an array of Phaser.Geom.Point objects
}</code>
</code></pre><p>The plugin comes with some methods for visually debugging your navmesh:</p><pre><code class="lang-js"><code class="source-code prettyprint">navMesh.enableDebug(); // Creates a Phaser.Graphics overlay on top of the screen
navMesh.debugDrawClear(); // Clears the overlay
// Visualize the underlying navmesh
navMesh.debugDrawMesh({
  drawCentroid: true,
  drawBounds: false,
  drawNeighbors: true,
  drawPortals: true
});
// Visualize an individual path
navMesh.debugDrawPath(path, 0xffd900);</code>
</code></pre><p>Check out the <a href="https://www.mikewesthad.com/navmesh/docs/identifiers.html#phaser-navmesh-src">API reference</a> for more information.</p><h3>phaser2-navmesh</h3><p>If you are working with Phaser 2, you can use the phaser2-navmesh package, which provides a game plugin. See this <a href="https://github.com/mikewesthad/navmesh/tree/master/packages/examples-phaser2/src">example</a> for more complete usage. You can also look at the <a href="#phaser-navmesh">previous section</a> for Phaser usage.</p><h2>Performance Comparison</h2><p><em>(Note: these comparisons were done in any earlier verison of the repo before Phaser v3 was released. The plugins tested haven&apos;t been released in v3 versions yet, so this section could use an update. That said, the results should be the same.)</em></p><p>Comparing this navmesh plugin against:</p><ul>
<li><a href="https://github.com/photonstorm/phaser-plugins">Phaser&apos;s grid-based A* plugin</a>. Navmesh is approximately 5x - 150x faster.</li>
<li>A faster, grid-based A* search, <a href="https://github.com/prettymuchbryce/easystarjs">EasyStar.js</a>. Navmesh is approximately 5x - 20x faster.</li>
</ul><p>Performance depends on the size of the area that needs to be searched. Finding for a path between points that are 50 pixels away is (generally) going to be much faster than finding a path between points that are 5000 pixels away.</p><p>Details (see <a href="https://github.com/mikewesthad/navmesh/tree/master/src/examples/performance">src/library/performance</a>):</p><pre><code><code class="source-code prettyprint">Performance Comparison, 100000 iterations, 30x30 tilemap

Short paths (150 - 500 pixel length)

    Average time per iteration:
        AStart Plugin: 0.02470ms
        EasyStar Plugin: 0.02876ms
        NavMesh Plugin: 0.00575ms

    Comparison:
        NavMesh is 4.30x faster than Phaser AStar
        NavMesh is 5.00x faster than EasyStar

Long paths (600 pixels and greater length), average time per iteration:

    Average time per iteration:
        AStart Plugin: 1.38710ms
        EasyStar Plugin: 0.15977ms
        NavMesh Plugin: 0.00738ms

    Comparison:
        NavMesh is 187.95x faster than Phaser AStar
        NavMesh is 21.65x faster than EasyStar</code>
</code></pre><h2>Development</h2><p>Pull requests are welcome (see <a href="#to-dos">todos</a>)! If you want to run this repo locally, make sure you have <a href="https://nodejs.org/en/">node</a> installed. Download the repo, open a terminal in the repo folder and run:</p><pre><code><code class="source-code prettyprint">npm install
npm run bootstrap</code>
</code></pre><p>This project uses <a href="https://github.com/lerna/lerna">lerna</a> and <a href="https://yarnpkg.com/lang/en/docs/workspaces/">yarn workspaces</a> to manage multiple packages within one repository. <code>npm install</code> will pull the root dependencies and <code>npm run bootstrap</code> will use lerna &amp; yarn to pull and link dependencies within &quot;packages/&quot;. This project has the following packages:</p><ul>
<li><code>navmesh</code> - core logic, game-engine agnostic</li>
<li><code>phaser-navmesh</code> - Phaser Plugin v3 wrapper around <code>navmesh</code></li>
<li><code>phaser2-navmesh</code> - Phaser Plugin v2 wrapper around <code>navmesh</code></li>
</ul><p>The project is controlled via npm scripts. The main ones to use:</p><ul>
<li><code>npm run build</code> - will build all the individual packages within &quot;packages/&quot;.</li>
<li><code>npm run dev</code> - watch &amp; serve the examples. A browser window will pop up with links to the examples. If you are working on the library, this is the easiest way to do &quot;functional testing&quot; by using the library in a game environment.</li>
<li><code>npm run test</code> - will run the automated tests against the library.</li>
</ul><h2>Changelogs</h2><ul>
<li><a href="https://github.com/mikewesthad/navmesh/blob/master/packages/phaser-navmesh/README.md">Phaser NavMesh (for Phaser v3)</a></li>
<li><a href="https://github.com/mikewesthad/navmesh/blob/master/packages/phaser2-navmesh/README.md">Phaser 2 NavMesh</a></li>
<li><a href="https://github.com/mikewesthad/navmesh/blob/master/packages/navmesh/README.md">NavMesh</a></li>
</ul><h2>References</h2><p>Helpful resources used while building this plugin:</p><ul>
<li>Inspired by <a href="https://github.com/nickjanssen/PatrolJS">PatrolJS</a>, an implementation of navmeshes for threejs</li>
<li>Navmesh path-finding algorithm explanations:<ul>
<li><a href="http://jceipek.com/Olin-Coding-Tutorials/pathing.html">Game Path Planning by Julian Ceipek</a></li>
<li><a href="http://digestingduck.blogspot.com/2010/03/simple-stupid-funnel-algorithm.html">Simple Stupid Funnel Algorithm</a></li>
</ul>
</li>
<li><a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html">Advice on astar heuristics</a></li>
</ul><h2>To Dos</h2><ul>
<li>Features<ul>
<li>Allow non-square navmesh polygons from Tiled - ideally, any convex shape.</li>
<li>Reimplement the autotessalation version of the lib &amp; try libtess in quad mode.</li>
<li>The astar heuristic &amp; cost functions need another pass. They don&apos;t always produce the shortest path. Implement incomplete funneling while building the astar path?</li>
<li>The navmesh assumes any polygon can reach any other polygon. This probably should be extended to put connected polygons into groups like patroljs.</li>
<li>Better warnings for devs - warn on empty map, warn on disconnected map, warn if polygons are malformed.</li>
<li>Factor in the layer position / scale / rotation</li>
</ul>
</li>
<li>Testing<ul>
<li>Check against tilemap that is larger than the screen</li>
</ul>
</li>
<li>Research<ul>
<li>There are probably optimization tricks to do when dealing with certain types of shapes. E.g. we are using axis-aligned boxes for the polygons and it is dead simple to calculate if a point is inside one of those...</li>
<li>Investigate <a href="http://www.david-gouveia.com/portfolio/pathfinding-on-a-2d-polygonal-map/">Points-of-Visibility</a> pathfinding to compare speed</li>
</ul>
</li>
</ul></div>
        <a data-ice="link" href="manual/README.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Creating a NavMesh in Tiled</h1><p><a href="http://www.mapeditor.org/">Tiled</a> is an open source tile map editor. If you are already using it to design your levels, then you can also use it to create your nav meshes.</p><p>Tiled allows you to design a map by creating <a href="http://doc.mapeditor.org/manual/layers/">layers</a> of tiles &amp; objects. A tile layer allows you to place your graphics (images from a tileset) into the world. An object layer allows you to store other kinds of information. Phaser can read both tile layers and object layers, so we can use the object layer to represent a nav mesh. In the image below, there is a layer of tiles (called &quot;walls&quot;) and a layer of gray rectangles that represents the nav mesh (called &quot;navmesh&quot;):</p><p><img src="./manual/./doc-source/tiled-guide/tiled-final.png"></p><p>This guide assumes you have some familiarity with Tiled. If you don&apos;t know Tiled, check out gamefromscratch&apos;s video <a href="http://www.gamefromscratch.com/post/2015/10/14/Tiled-Map-Editor-Tutorial-Series.aspx">tutorial series</a>.</p><h2>Goal</h2><p>The idea is that we want to create an object layer in Tiled that represents where an &quot;agent&quot; (the player, an enemy, an npc, etc.) can move. We will describe those walkable area by placing individual shapes (mainly rectangles). An agent can then &quot;walk&quot; from one shape to another as long as they are connected (i.e. their edges overlap).</p><p>Note: We will also want to take the agent&apos;s size into account when building the shapes. If you have an agent that is 20px wide, then it shouldn&apos;t be allowed to get within 10px of a wall.</p><h2>Snapping Setup</h2><p>In order to place shapes in the nav mesh accurately and ensure that neighboring shapes are &quot;connected,&quot; you&apos;ll want to enable snapping. Open up your map or create a new one, and go to preferences (<code>Edit &#x27F6; Preferences</code>):</p><p><img src="./manual/./doc-source/tiled-guide/tiled-preferences.png"></p><p>Set the fine grid divisions. This allows you to snap objects &quot;in-between&quot; the grid. E.g. on a 25px x 25px tile map with 5 grid divisions, the fine grid would be every 5px.</p><p><img src="./manual/./doc-source/tiled-guide/tiled-preferences-2.png"></p><p>Enable snapping (<code>View &#x27F6; Snapping</code>):</p><p><img src="./manual/./doc-source/tiled-guide/tiled-snapping.png"></p><h2>Creating the Mesh</h2><p>Create a new object layer and name it &quot;navmesh.&quot; Then start adding in rectangles to define your nav mesh. (Note: rectangles are the only Tiled shape currently supported by this plugin.)</p><p><img src="./manual/./doc-source/tiled-guide/tiled-navmesh-layer.gif"></p><p>See the Tiled manual for more information on <a href="http://doc.mapeditor.org/manual/objects/#working-with-objects">objects</a>.</p><h2>Agent Size (Gaps)</h2><p>Notice the 10px space left around the walls? That gap is because the agent is 20px wide circle. It would get stuck on corners of walls without that gap. Make sure the gaps you leave are a consistent size - you&apos;ll need to pass in the size as the third parameter to <code>plugin.buildMeshFromTiled</code>.</p><p>If you wanted, you <em>could</em> leave that gap out and write more complicated path following logic for your agents that avoids getting stuck. &quot;Baking&quot; the agent size into nav mesh with these gaps makes the path following logic pretty simple.</p></div>
        <a data-ice="link" href="manual/tiled-navmesh-guide.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
